<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bremsweg-Messung Mobil</title>
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #f5f6fa; margin: 0; }
    .container { max-width: 400px; margin: 2rem auto; background: #fff; border-radius: 1rem; box-shadow: 0 4px 24px rgba(0,0,0,0.12); padding: 2rem; }
    h1 { text-align: center; }
    label { display: block; margin-top: 1rem; }
    input, select { width: 100%; padding: 0.5rem; margin-top: 0.5rem; border-radius: 0.5rem; border: 1px solid #ccc; }
    button { margin-top: 1.5rem; width: 100%; padding: 1rem; border: none; border-radius: 0.5rem; background: #4cd137; color: #fff; font-size: 1.2rem; cursor: pointer; }
    button:disabled { background: #aaa; }
    .result { margin-top: 2rem; background: #f0f0f0; padding: 1rem; border-radius: 0.5rem; }
    .status { margin-top: 1rem; color: #888; font-size: 0.9rem; }
    .speed { font-size: 1.2rem; margin-top: 1rem; text-align: center; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Bremsweg-Messung</h1>
    <div class="speed" id="speed">Geschwindigkeit: 0 m/s</div>
    <div class="speed" id="gps">GPS: - / -</div>
    <label>Schwellenwert Verzögerung (m/s²):
      <input type="number" id="decelThreshold" value="2" min="0" step="0.1">
    </label>
    <label>Richtung (X, Y, Z, Betrag):
      <select id="direction">
        <option value="x">X</option>
        <option value="y">Y</option>
        <option value="z">Z</option>
        <option value="betrag">Betrag</option>
      </select>
    </label>
    <div style="margin-top:0.5rem;">
      <label>Verdrehwinkel um X (°): <input type="number" id="winkelX" value="0" min="-180" max="180" step="0.1"></label>
      <label>Verdrehwinkel um Y (°): <input type="number" id="winkelY" value="0" min="-180" max="180" step="0.1"></label>
      <label>Verdrehwinkel um Z (°): <input type="number" id="winkelZ" value="0" min="-180" max="180" step="0.1"></label>
    </div>
    <label style="margin-top:0.5rem;display:block;">
      <input type="checkbox" id="gravityToggle" checked>
      Mit Gravitation messen
    </label>
    <label>Schwellenwert Stillstand (m/s²):
      <input type="number" id="stopThreshold" value="0.3" min="0" step="0.01">
    </label>
    <button id="startBtn">Messung starten</button>
    <button id="stopBtn" style="background:#e84118;margin-top:0.5rem;">Messung beenden</button>
    <button id="clearBtn" style="background:#888;margin-top:0.5rem;">Clear</button>
    <div class="speed" id="acceleration">Verzögerung: 0 m/s²</div>
    <div class="status" id="status"></div>
    <div class="result" id="result"></div>
    <div class="result" id="resultsList"></div>
    <button id="exportBtn" style="background:#0097e6;margin-top:1.5rem;">Export als Excel</button>
  </div>
  <script>
    let measuring = false;
    let waitingForDecel = false;
    let startTime = null;
    let stopTime = null;
    let decelThreshold = 2;
    let stopThreshold = 0.3;
    let direction = 'x';
    let useGravity = true;
    let startSpeed = 0;
    let currentSpeed = 0;
    let distance = 0;
    let lastSpeed = 0;
    let watchId = null;
    let results = [];
let accHistory = []; // Für Plot und Mittelwert
let accHistories = []; // Für Excel-Export
let plotPNGs = []; // Für Anzeige der Historie

    document.getElementById('startBtn').onclick = function() {
      decelThreshold = parseFloat(document.getElementById('decelThreshold').value);
      stopThreshold = parseFloat(document.getElementById('stopThreshold').value);
      direction = document.getElementById('direction').value;
      measuring = false;
      waitingForDecel = true;
      startTime = null;
      stopTime = null;
      distance = 0;
      document.getElementById('result').innerHTML = '';
      document.getElementById('status').innerHTML = 'Warte auf Verzögerung...';
      document.getElementById('acceleration').innerHTML = 'Verzögerung: 0 m/s²';
    };

    document.getElementById('direction').onchange = function() {
      direction = document.getElementById('direction').value;
    };
    document.getElementById('winkelX').oninput = document.getElementById('winkelY').oninput = document.getElementById('winkelZ').oninput = function() {
      // Trigger Echtzeit-Update
    };
    document.getElementById('gravityToggle').onchange = function() {
      useGravity = document.getElementById('gravityToggle').checked;
    };

    document.getElementById('stopBtn').onclick = function() {
      measuring = false;
      waitingForDecel = false;
      startTime = null;
      stopTime = null;
      distance = 0;
      document.getElementById('result').innerHTML = '';
      document.getElementById('status').innerHTML = 'Messung gestoppt. Werte können angepasst werden.';
      document.getElementById('acceleration').innerHTML = 'Verzögerung: 0 m/s²';
    };

    document.getElementById('clearBtn').onclick = function() {
      results = [];
      updateResultsList();
    };

    function calcNormBremsweg(accHistory, startSpeed, bremszeit) {
  // 1. Normiere die Verzögerungskurve so, dass die Geschwindigkeit am Ende 0 ist
  // 2. Integriere die Geschwindigkeit über die Zeit für den Bremsweg
  let n = accHistory.length;
  if (n < 2) return 0;
  // Zeitdifferenzen und Roh-Integral der Verzögerung
  let v = [parseFloat(startSpeed)];
  let t0 = accHistory[0].t;
  let tN = accHistory[n-1].t;
  let dtSum = 0;
  for (let i=1; i<n; i++) {
    let dt = accHistory[i].t - accHistory[i-1].t;
    dtSum += dt;
    v[i] = v[i-1] - accHistory[i].a * dt; // Roh-Geschwindigkeit
  }
  // Normierungsfaktor berechnen, damit v[n-1] = 0
  let norm = v[n-1] !== 0 ? v[0] / (v[0] - v[n-1]) : 1;
  // Normierte Verzögerungskurve
  let vNorm = [v[0]];
  for (let i=1; i<n; i++) {
    let dt = accHistory[i].t - accHistory[i-1].t;
    vNorm[i] = vNorm[i-1] - accHistory[i].a * norm * dt;
  }
  // Bremsweg als Integral der normierten Geschwindigkeit
  let s = 0;
  for (let i=1; i<n; i++) {
    let dt = accHistory[i].t - accHistory[i-1].t;
    s += (vNorm[i-1] + vNorm[i]) / 2 * dt;
  }
  return s;
}

    function updateResultsList() {
      const listDiv = document.getElementById('resultsList');
      if (results.length === 0) {
        listDiv.innerHTML = '';
        return;
      }
  let html = '<b>Messungen:</b>';
  results.forEach((r, i) => {
    html += `<div style='margin-bottom:1.5em;padding:0.5em;background:#f8f8f8;border-radius:0.5em;'>`;
    html += `<b>Nr. ${i+1}</b>: Zeit: ${r.time}s, Startgeschw.: ${r.startSpeed}m/s, Bremsweg: ${r.distance}m`;
    html += `<br><span style='color:#888;'>Vergleichsbremsweg (konstant): ${r.vergleichsweg} m</span>`;
    html += `<br>Mittlere Verzögerung: ${r.meanA} m/s²`;
    html += `<br><span style='color:#888;'>Bremsweg (normierte Kurve): ${r.normBremsweg} m</span>`;
    if (plotPNGs[i]) {
      html += `<br><img src='${plotPNGs[i]}' style='width:320px;border:1px solid #ccc;margin-top:0.5em;'>`;
    }
    html += `</div>`;
  });
  listDiv.innerHTML = html;
    }

    document.getElementById('stopBtn').onclick = function() {
      measuring = false;
      startTime = null;
      stopTime = null;
      distance = 0;
      document.getElementById('result').innerHTML = '';
      document.getElementById('status').innerHTML = 'Messung gestoppt. Werte können angepasst werden.';
      document.getElementById('acceleration').innerHTML = 'Verzögerung: 0 m/s²';
    };

    // GPS Geschwindigkeit und Position
    if ('geolocation' in navigator) {
      watchId = navigator.geolocation.watchPosition(function(pos) {
        if (pos.coords.speed != null) {
          currentSpeed = Math.max(0, pos.coords.speed);
          document.getElementById('speed').innerHTML = `Geschwindigkeit: ${currentSpeed.toFixed(2)} m/s`;
        }
        if (pos.coords.latitude != null && pos.coords.longitude != null) {
          document.getElementById('gps').innerHTML = `GPS: ${pos.coords.latitude.toFixed(6)} / ${pos.coords.longitude.toFixed(6)}`;
        }
      }, function(err) {
        document.getElementById('speed').innerHTML = 'GPS nicht verfügbar';
        document.getElementById('gps').innerHTML = 'GPS: - / -';
      }, { enableHighAccuracy: true, maximumAge: 1000 });
    } else {
      document.getElementById('speed').innerHTML = 'GPS nicht verfügbar';
      document.getElementById('gps').innerHTML = 'GPS: - / -';
    }

    function rotateVector(x, y, z, wx, wy, wz) {
      // Rotationsmatrizen für x, y, z
      let radX = wx * Math.PI / 180;
      let radY = wy * Math.PI / 180;
      let radZ = wz * Math.PI / 180;
      // Rotation um X
      let y1 = y * Math.cos(radX) - z * Math.sin(radX);
      let z1 = y * Math.sin(radX) + z * Math.cos(radX);
      let x1 = x;
      // Rotation um Y
      let x2 = x1 * Math.cos(radY) + z1 * Math.sin(radY);
      let z2 = -x1 * Math.sin(radY) + z1 * Math.cos(radY);
      let y2 = y1;
      // Rotation um Z
      let x3 = x2 * Math.cos(radZ) - y2 * Math.sin(radZ);
      let y3 = x2 * Math.sin(radZ) + y2 * Math.cos(radZ);
      let z3 = z2;
      return {x: x3, y: y3, z: z3};
    }

    window.addEventListener('devicemotion', function(event) {
      let acc = useGravity ? event.accelerationIncludingGravity : event.acceleration;
      if (!acc) return;
      let wx = parseFloat(document.getElementById('winkelX').value) || 0;
      let wy = parseFloat(document.getElementById('winkelY').value) || 0;
      let wz = parseFloat(document.getElementById('winkelZ').value) || 0;
      let vec = rotateVector(acc.x || 0, acc.y || 0, acc.z || 0, wx, wy, wz);
      let a = 0;
      if (direction === 'betrag') {
        a = Math.sqrt(
          Math.pow(vec.x, 2) +
          Math.pow(vec.y, 2) +
          Math.pow(vec.z, 2)
        );
      } else {
        a = vec[direction] || 0;
      }
      document.getElementById('acceleration').innerHTML = `Verzögerung${useGravity ? ' inkl. Gravitation' : ''}: ${a.toFixed(2)} m/s²`;
      // Echtzeit-Update der Verzögerung
      if (waitingForDecel && Math.abs(a) >= decelThreshold) {
        measuring = true;
        waitingForDecel = false;
        startTime = performance.now();
        startSpeed = currentSpeed;
        accHistory = [];
        accHistory.push({t: 0, a: a});
        document.getElementById('status').innerHTML = 'Messung läuft...';
      }
      if (measuring) {
        let dt = event.interval ? event.interval / 1000 : 0.02;
        startSpeed = startSpeed || currentSpeed;
        startSpeed = Math.max(0, startSpeed);
        startSpeed = isNaN(startSpeed) ? 0 : startSpeed;
        startSpeed = Math.max(startSpeed, 0);
        startSpeed = Math.min(startSpeed, 100);
        startSpeed = parseFloat(startSpeed);
        currentSpeed -= Math.abs(a) * dt;
        if (currentSpeed < 0) currentSpeed = 0;
        distance += currentSpeed * dt;
        // Verzögerung und Zeit für Plot speichern
        let t = (performance.now() - startTime) / 1000;
        accHistory.push({t: t, a: a});
        if (Math.abs(a) <= stopThreshold && currentSpeed <= stopThreshold) {
          measuring = false;
          stopTime = performance.now();
          let time = ((stopTime - startTime) / 1000).toFixed(2);
          // Mittelwert der Verzögerung berechnen
          let meanA = 0;
          if (accHistory.length > 1) {
            let sum = 0;
            for (let i = 1; i < accHistory.length; i++) {
              let dt = accHistory[i].t - accHistory[i-1].t;
              sum += Math.abs(accHistory[i].a) * dt;
            }
            meanA = sum / (accHistory[accHistory.length-1].t);
          }
          // Vergleichsbremsweg bei konstanter Verzögerung
          let vergleichsweg = meanA > 0 ? (Math.pow(startSpeed,2)/(2*meanA)) : 0;
          // Alternative Methode: normierte Verzögerungskurve
          let normBremsweg = calcNormBremsweg(accHistory, startSpeed, (stopTime-startTime)/1000);
          document.getElementById('result').innerHTML =
            `<b>Messung beendet!</b><br>Benötigte Zeit: ${time} s<br>Geschätzter Weg: ${distance.toFixed(2)} m<br>Startgeschwindigkeit: ${startSpeed.toFixed(2)} m/s` +
            `<br>Mittlere Verzögerung: ${meanA.toFixed(2)} m/s²` +
            `<br><span style='color:#888;'>Vergleichsbremsweg (konstant): ${vergleichsweg.toFixed(2)} m</span>` +
            `<br><span style='color:#888;'>Bremsweg (normierte Kurve): ${normBremsweg.toFixed(2)} m</span>`;
          document.getElementById('status').innerHTML = 'Stillstand erkannt.';
          // Plot anzeigen und PNG für Historie erzeugen
          let png = showAccPlot(accHistory, true);
          plotPNGs.push(png);
          // Messwerte für Excel speichern
          accHistories.push(accHistory.map(d => ({t: d.t, a: d.a})));
          // Ergebnis speichern und anzeigen
          results.push({
            time: time,
            startSpeed: startSpeed.toFixed(2),
            distance: distance.toFixed(2),
            vergleichsweg: vergleichsweg.toFixed(2),
            meanA: meanA.toFixed(2),
            normBremsweg: normBremsweg.toFixed(2)
          });
          updateResultsList();
          // App zurücksetzen für neue Messung
          waitingForDecel = false;
          measuring = false;
        }
      }
    });

// Plot-Funktion für Verzögerung über Zeit
function showAccPlot(data, returnPNG=false) {
  let plotDiv = document.getElementById('result');
  let w = 320, h = 140, pad = 40;
  let canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  canvas.style.marginTop = '1em';
  let ctx = canvas.getContext('2d');
  // Achsen
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(pad, h-pad);
  ctx.lineTo(w-pad, h-pad);
  ctx.moveTo(pad, h-pad);
  ctx.lineTo(pad, pad);
  ctx.stroke();
  // Achsenbeschriftungen
  ctx.fillStyle = '#222';
  ctx.font = '14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Zeit (s)', w/2, h-10);
  ctx.save();
  ctx.translate(15, h/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = 'center';
  ctx.fillText('Verzögerung (m/s²)', 0, 0);
  ctx.restore();
  // Wertebereich
  let tmax = data[data.length-1].t;
  let amin = Math.min(...data.map(d=>d.a));
  let amax = Math.max(...data.map(d=>d.a));
  if (amin === amax) { amin -= 1; amax += 1; }
  // Plot
  ctx.strokeStyle = '#e84118';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i=0; i<data.length; i++) {
    let x = pad + (w-2*pad) * (data[i].t/tmax);
    let y = h-pad - (h-2*pad) * ((data[i].a-amin)/(amax-amin));
    if (i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();
  // Y-Achse Werte
  ctx.fillStyle = '#444';
  ctx.font = '12px Segoe UI';
  ctx.textAlign = 'right';
  ctx.fillText(amin.toFixed(1), pad-5, h-pad);
  ctx.fillText(amax.toFixed(1), pad-5, pad+5);
  // X-Achse Werte
  ctx.textAlign = 'center';
  ctx.fillText('0', pad, h-pad+15);
  ctx.fillText(tmax.toFixed(2), w-pad, h-pad+15);
  if (!returnPNG) {
    plotDiv.appendChild(canvas);
    return;
  } else {
    return canvas.toDataURL('image/png');
  }
}
// SheetJS für Excel-Export einbinden
let sheetjsLoaded = false;
function loadSheetJS(cb) {
  if (sheetjsLoaded) { cb(); return; }
  let script = document.createElement('script');
  script.src = 'https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js';
  script.onload = function() { sheetjsLoaded = true; cb(); };
  document.body.appendChild(script);
}

document.getElementById('exportBtn').onclick = function() {
  loadSheetJS(function() {
    let wb = XLSX.utils.book_new();
    let ws_data = [['Nr','Zeit (s)','Startgeschw. (m/s)','Bremsweg (m)','Vergleichsbremsweg (m)','Mittlere Verzögerung (m/s²)','Bremsweg (normierte Kurve)']];
    results.forEach((r,i)=>{
      ws_data.push([i+1, r.time, r.startSpeed, r.distance, r.vergleichsweg, r.meanA, r.normBremsweg]);
    });
    let ws = XLSX.utils.aoa_to_sheet(ws_data);
    XLSX.utils.book_append_sheet(wb, ws, 'Messungen');
    // Messwerte als weitere Sheets
    accHistories.forEach((hist,i)=>{
      let plotData = [['Zeit (s)','Verzögerung (m/s²)']];
      hist.forEach(d=>{
        plotData.push([d.t.toFixed(3), d.a.toFixed(3)]);
      });
      let plotSheet = XLSX.utils.aoa_to_sheet(plotData);
      XLSX.utils.book_append_sheet(wb, plotSheet, `Plot${i+1}`);
    });
    XLSX.writeFile(wb, 'bremsweg_messungen.xlsx');
  });
};
  </script>
</body>
</html>
