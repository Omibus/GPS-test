*** ENDE PATCH: DEBUG-Block entfernt ***
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bremsweg-Messung Mobil</title>
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #f5f6fa; margin: 0; }
    .container { max-width: 400px; margin: 2rem auto; background: #fff; border-radius: 1rem; box-shadow: 0 4px 24px rgba(0,0,0,0.12); padding: 2rem; padding-left:2rem; padding-right:2rem; }
    h1 { text-align: center; }
    label { display: block; margin-top: 1rem; }
    input, select { width: 100%; padding: 0.5rem; margin: 0; border-radius: 0.5rem; border: 1px solid #ccc; box-sizing: border-box; height: 2.5em; }
    button { margin-top: 1.5rem; width: 100%; padding: 1rem; border: none; border-radius: 0.5rem; background: #4cd137; color: #fff; font-size: 1.2rem; cursor: pointer; box-sizing: border-box; }
    .inline-btn, .inline-btn-clear {
      width: calc(2.5em + 2px); /* exakt wie input inkl. border */
      height: calc(2.5em + 2px);
      padding: 0;
      margin: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      border-radius: 0.5em;
      border: 1px solid #ccc;
      background: #eee;
      color: #222;
      box-sizing: border-box;
    }
    .inline-btn-clear { color:#e84118; font-size:1.3em; }
    .inline-btn:active, .inline-btn-clear:active { background:#ddd; }
    .flex-row { display:flex; align-items:center; gap:0.5em; margin-top:0.5em; }
    .flex-row { display:flex; align-items:center; gap:0.5em; margin-top:0.5em; }
    button:disabled { background: #aaa; }
    .result { margin-top: 2rem; background: #f0f0f0; padding: 1rem; border-radius: 0.5rem; }
    .status { margin-top: 1rem; color: #888; font-size: 0.9rem; }
    .speed { font-size: 1.2rem; margin-top: 1rem; text-align: center; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Bremsweg-Messung</h1>
    <div class="speed" id="speed">Geschwindigkeit: 0 m/s</div>
    <div class="speed" id="gps">GPS: - / -</div>
    <div style="margin-top:0.5rem; display:flex; gap:0.5em; align-items:center;">
      <button id="calibBtn" type="button" style="background:#fbc531;color:#222;padding:0.5em 1em;border:none;border-radius:0.5em;">calib. grav.</button>
      <button id="calibBreakBtn" type="button" style="background:#00a8ff;color:#fff;padding:0.5em 1em;border:none;border-radius:0.5em;">calib. break</button>
    </div>
  <!-- Debug-Bereich für Rohdatensatz-Injektion -->
  <div class="result" style="margin-top:2em;">
    <b>Debug: Rohdatensatz aus Datei auswerten</b><br>
    <label for="debugRohDropdown">Rohdatensatz:</label>
    <select id="debugRohDropdown" style="margin-right:1em;">
      <option value="1">Rohdatensatz 1</option>
      <option value="2">Rohdatensatz 2</option>
      <option value="3">Rohdatensatz 3</option>
    </select>
    <label for="debugV0Input">Anfangsgeschwindigkeit (m/s):</label>
    <input type="number" id="debugV0Input" value="0" min="0" step="0.1" style="width:5em;margin-right:1em;">
    <button id="debugRohBtn" style="background:#e1b12c;">Debug: Rohdaten auswerten</button>
  </div>
    <div class="flex-row"><span>Schwellenwert Verzögerung (m/s²):</span>
      <button id="decelLeft" type="button" class="inline-btn">-</button>
      <input type="number" id="decelThreshold" value="2" min="0" step="0.1" style="flex:1;min-width:60px;">
      <button id="decelRight" type="button" class="inline-btn">+</button>
    </div>
    <div class="flex-row"><span>Schwellenwert Stillstand (m/s²):</span>
      <button id="stopLeft" type="button" class="inline-btn">-</button>
      <input type="number" id="stopThreshold" value="0.3" min="0" step="0.01" style="flex:1;min-width:60px;">
      <button id="stopRight" type="button" class="inline-btn">+</button>
    </div>
    <div class="flex-row"><span>Richtung (X, Y, Z, Betrag):</span>
      <select id="direction" style="flex:1;">
        <option value="x">X</option>
        <option value="y" selected>Y</option>
        <option value="z">Z</option>
        <option value="betrag">Betrag</option>
      </select>
    </div>
    <div class="flex-row"><span>Verdrehwinkel um X (°):</span>
      <input type="number" id="winkelX" value="0" min="-180" max="180" step="0.1" style="flex:1;">
      <button id="clearWinkelX" type="button" class="inline-btn-clear">&#10006;</button>
    </div>
    <div class="flex-row"><span>Verdrehwinkel um Y (°):</span>
      <input type="number" id="winkelY" value="0" min="-180" max="180" step="0.1" style="flex:1;">
      <button id="clearWinkelY" type="button" class="inline-btn-clear">&#10006;</button>
    </div>
    <div class="flex-row"><span>Verdrehwinkel um Z (°):</span>
      <input type="number" id="winkelZ" value="0" min="-180" max="180" step="0.1" style="flex:1;">
      <button id="clearWinkelZ" type="button" class="inline-btn-clear">&#10006;</button>
    </div>
    <label style="margin-top:0.5rem;display:block;">
      <input type="checkbox" id="gravityToggle">
      Mit Gravitation messen
    </label>
    <button id="startBtn">Messung starten</button>
    <button id="stopBtn" style="background:#e84118;margin-top:0.5rem;">Messung beenden</button>
    <button id="clearBtn" style="background:#888;margin-top:0.5rem;">Clear</button>
    <div class="speed" id="acceleration">Verzögerung: 0 m/s²</div>
    <div class="status" id="status"></div>
    <div class="result" id="resultsList"></div>
    <button id="exportBtn" style="background:#0097e6;margin-top:1.5rem;">Export als Excel</button>
    <button id="debugSinusBtn" style="background:#e1b12c;margin-top:1em;">DEBUG: Sinus-Testdiagramm</button>
  </div>
  <script>
// --- Rohdatensätze als JS-Arrays ---
const debugRohdaten = {
  1: [
    // Rohdatensatz1.csv
    [0.000,0.000],[0.017,-0.100],[0.033,-0.100],[0.050,0.000],[0.067,0.100],[0.083,0.000],[0.100,0.000],[0.117,0.000],[0.133,0.000],[0.150,0.000],[0.167,0.100],[0.183,0.100],[0.200,0.000],[0.216,-0.100],[0.233,-0.100],[0.250,0.000],[0.267,0.000],[0.283,0.000],[0.300,0.000],[0.317,0.000],[0.333,0.000],[0.350,-0.100],[0.367,0.100],[0.383,0.200],[0.400,0.000],[0.416,-0.100],[0.433,-0.100],[0.450,0.000],[0.466,-0.200],[0.483,-0.100],[0.500,0.000],[0.516,0.000],[0.533,0.000],[0.550,0.000],[0.567,0.000],[0.583,-0.100],[0.600,0.100],[0.616,0.200],[0.633,0.000],[0.650,0.000],[0.666,0.000],[0.683,0.000],[0.700,0.000],[0.716,0.000],[0.733,0.000],[0.750,0.000],[0.766,0.000],[0.783,0.000],[0.800,0.100],[0.817,0.000],[0.833,0.000],[0.850,0.100],[0.866,0.100],[0.883,0.400],[0.900,0.700],[0.916,1.100],[0.933,1.600],[0.950,1.700],[0.966,1.900],[0.983,1.900],[1.000,2.300],[1.017,2.900],[1.033,3.800],[1.050,4.800],[1.067,5.500],[1.083,6.200],[1.100,6.300],[1.117,6.300],[1.133,6.200],[1.150,6.200],[1.167,6.100],[1.183,5.500],[1.200,3.700],[1.216,1.200],[1.233,0.800],[1.250,0.300],[1.267,-3.200],[1.283,-6.900],[1.300,-13.900],[1.316,-21.700],[1.333,-28.100],[1.350,-34.100],[1.366,-26.700],[1.383,-15.700],[1.401,-10.400],[1.417,-7.300],[1.433,-4.300],[1.450,1.200],[1.467,5.800],[1.483,9.800],[1.500,11.300],[1.517,12.700],[1.533,12.600],[1.550,10.900],[1.567,7.600],[1.583,5.900],[1.600,5.100],[1.616,5.300],[1.633,5.000],[1.650,3.600],[1.666,1.300],[1.683,1.300],[1.700,-1.300],[1.716,-1.300],[1.733,-1.800],[1.750,-2.000],[1.767,-1.900],[1.783,-0.900],[1.800,-0.300],[1.817,-0.300],[1.833,-0.200],[1.850,-0.100],[1.866,0.100],[1.883,0.200],[1.900,0.200],[1.917,0.100],[1.933,0.000],[1.950,-0.100],[1.966,0.000],[1.983,0.100],[2.000,0.200],[2.017,0.200],[2.033,0.200],[2.050,0.100],[2.067,0.100],[2.083,-0.100],[2.100,-0.300],[2.116,-0.300],[2.133,-0.100],[2.150,0.100],[2.167,0.100],[2.183,-0.100],[2.200,-0.100],[2.216,-0.100],[2.233,-0.100],[2.250,-0.200]
  ],
  2: [
    // Rohdatensatz2.csv
    [0.000,0.100],[0.017,0.100],[0.034,0.100],[0.050,0.100],[0.067,0.100],[0.083,0.100],[0.100,0.100],[0.117,0.100],[0.133,0.200],[0.150,0.100],[0.167,0.100],[0.183,0.000],[0.200,0.100],[0.217,0.100],[0.233,0.100],[0.250,0.100],[0.267,0.000],[0.283,0.100],[0.300,0.100],[0.317,0.100],[0.334,0.100],[0.350,0.200],[0.367,0.100],[0.383,0.100],[0.400,0.100],[0.417,0.100],[0.433,0.200],[0.450,0.100],[0.467,0.100],[0.484,0.200],[0.500,0.200],[0.517,0.200],[0.533,0.100],[0.550,0.200],[0.567,0.200],[0.583,0.300],[0.600,0.200],[0.617,0.400],[0.633,0.300],[0.650,0.500],[0.667,0.400],[0.683,0.400],[0.700,0.400],[0.717,0.600],[0.733,0.700],[0.750,0.700],[0.767,0.600],[0.783,0.600],[0.800,0.700],[0.817,0.800],[0.833,0.900],[0.850,0.900],[0.867,0.900],[0.883,1.000],[0.900,1.200],[0.917,1.400],[0.933,1.600],[0.950,1.700],[0.967,1.600],[0.984,1.600],[1.000,2.100],[1.018,2.600],[1.033,2.700],[1.050,2.700],[1.067,2.500],[1.083,2.700],[1.100,3.300],[1.117,3.600],[1.133,3.600],[1.150,3.800],[1.167,3.900],[1.183,4.400],[1.200,4.700],[1.217,4.800],[1.233,5.000],[1.250,5.200],[1.267,5.300],[1.283,5.500],[1.300,5.700],[1.317,5.900],[1.333,5.800],[1.350,6.000],[1.367,6.100],[1.383,6.100],[1.400,6.400],[1.417,6.300],[1.433,6.300],[1.450,6.500],[1.467,6.700],[1.483,6.600],[1.500,6.600],[1.517,6.800],[1.533,6.800],[1.550,6.900],[1.567,6.800],[1.583,7.000],[1.600,7.100],[1.617,7.100],[1.633,7.100],[1.650,7.000],[1.667,7.200],[1.683,7.200],[1.700,7.100],[1.717,7.100],[1.733,7.200],[1.750,7.100],[1.767,7.200],[1.783,7.400],[1.800,7.200],[1.817,7.200],[1.833,7.300],[1.850,7.200],[1.867,7.200],[1.883,7.100],[1.900,7.000],[1.917,7.000],[1.933,7.000],[1.950,7.000],[1.967,7.000],[1.983,6.900],[2.000,6.800],[2.017,6.800],[2.035,6.700],[2.050,6.600],[2.067,6.500],[2.083,6.600],[2.100,6.500],[2.117,6.200],[2.134,6.100],[2.150,6.100],[2.167,6.000],[2.183,5.800],[2.200,5.500],[2.217,5.500],[2.233,5.300],[2.250,5.200],[2.267,4.800],[2.283,4.400],[2.300,4.300],[2.317,4.100],[2.333,3.800],[2.350,3.400],[2.367,3.100],[2.383,3.000],[2.400,2.600],[2.417,2.300],[2.433,2.100],[2.450,1.600],[2.467,1.200],[2.483,1.200],[2.500,1.200],[2.517,1.200],[2.533,0.700],[2.550,0.600],[2.567,0.400],[2.583,0.300],[2.600,0.300],[2.617,0.200],[2.634,0.300],[2.650,0.100],[2.667,0.100],[2.683,0.100],[2.700,0.100],[2.717,0.100],[2.733,0.100],[2.750,-0.100],[2.767,0.000],[2.783,0.100],[2.800,0.200],[2.817,0.100],[2.833,0.100],[2.850,-0.200],[2.867,0.000],[2.883,0.000],[2.900,0.100],[2.917,0.200],[2.933,0.100],[2.950,0.100],[2.967,0.200],[2.983,0.300],[3.000,0.300],[3.017,0.300],[3.033,0.200],[3.050,0.200],[3.067,0.100],[3.083,0.200],[3.100,0.300],[3.117,0.200],[3.133,0.200],[3.151,0.300],[3.167,0.300],[3.183,0.200],[3.200,0.200],[3.216,0.200],[3.233,0.200],[3.250,0.400],[3.267,0.300],[3.284,0.300],[3.300,0.200],[3.317,0.300],[3.333,0.300],[3.350,0.300],[3.367,0.200],[3.383,0.300],[3.400,0.300],[3.417,0.400],[3.433,0.300],[3.450,0.200],[3.467,0.300],[3.483,0.300],[3.500,0.300],[3.517,0.300],[3.534,0.300],[3.550,0.200],[3.567,0.200],[3.583,0.300],[3.600,0.300],[3.617,0.300]
  ],
  3: [
    // Rohdatensatz3.csv
    [0.000,0.300],[0.017,0.300],[0.033,0.300],[0.050,0.300],[0.067,0.200],[0.083,0.300],[0.100,0.300],[0.117,0.300],[0.133,0.300],[0.150,0.300],[0.167,0.300],[0.183,0.300],[0.200,0.300],[0.217,0.400],[0.233,0.300],[0.250,0.300],[0.267,0.300],[0.283,0.300],[0.300,0.400],[0.317,0.300],[0.333,0.300],[0.350,0.300],[0.367,0.300],[0.383,0.400],[0.400,0.400],[0.417,0.300],[0.433,0.300],[0.450,0.300],[0.467,0.300],[0.483,0.300],[0.500,0.400],[0.517,0.300],[0.533,0.300],[0.550,0.300],[0.567,0.300],[0.583,0.300],[0.600,0.400],[0.617,0.300],[0.633,0.300],[0.650,0.300],[0.667,0.400],[0.683,0.400],[0.700,0.400],[0.717,0.300],[0.733,0.200],[0.750,0.200],[0.767,0.300],[0.783,0.300],[0.800,0.300],[0.817,0.300],[0.833,0.200],[0.850,0.300],[0.867,0.200],[0.883,0.100],[0.900,0.000],[0.917,-0.400],[0.933,-0.800],[0.950,-1.300],[0.967,-1.600],[0.983,-1.800],[1.000,-2.300],[1.017,-2.400],[1.033,-3.100],[1.050,-3.400],[1.067,-3.600],[1.083,-3.700],[1.100,-3.700],[1.117,-4.200],[1.133,-4.000],[1.150,-3.900],[1.167,-3.900],[1.183,-4.600],[1.200,-4.800],[1.217,-4.400],[1.233,-4.800],[1.250,-5.300],[1.267,-5.200],[1.283,-5.200],[1.300,-5.200],[1.317,-5.000],[1.333,-5.600],[1.350,-5.400],[1.367,-5.500],[1.383,-5.900],[1.400,-5.800],[1.417,-5.800],[1.433,-5.600],[1.450,-5.600],[1.467,-5.600],[1.483,-5.600],[1.500,-5.700],[1.517,-5.700],[1.533,-5.900],[1.550,-5.900],[1.567,-5.500],[1.583,-5.100],[1.600,-5.100],[1.617,-5.200],[1.633,-4.900],[1.650,-4.800],[1.667,-5.000],[1.683,-5.000],[1.700,-4.600],[1.717,-4.300],[1.733,-4.200],[1.750,-5.300],[1.767,-5.000],[1.783,-3.800],[1.801,-3.200],[1.817,-3.100],[1.833,-3.400],[1.850,-3.400],[1.867,-0.400],[1.883,1.600],[1.900,2.100],[1.917,2.400],[1.933,3.700],[1.950,5.100],[1.967,4.800],[1.983,3.200],[2.000,0.700],[2.017,-0.500],[2.033,-1.200],[2.050,-1.500],[2.067,-1.600],[2.083,-1.800],[2.101,-1.800],[2.117,-1.600],[2.133,-2.000],[2.150,-2.100],[2.167,-1.800],[2.183,-1.700],[2.200,-1.700],[2.217,-1.600],[2.233,-1.700],[2.250,-1.500],[2.267,-1.500],[2.283,-0.400],[2.300,0.600],[2.317,1.100],[2.333,1.200],[2.350,1.600],[2.367,2.600],[2.383,3.000],[2.400,1.600],[2.417,0.400],[2.433,-0.100],[2.450,0.100],[2.467,0.000],[2.483,0.300],[2.500,0.100],[2.517,-0.500],[2.533,-0.600],[2.550,-0.400],[2.567,-0.200],[2.583,0.500],[2.600,0.800],[2.617,1.000],[2.633,1.200],[2.650,1.200],[2.667,1.100],[2.683,1.100],[2.700,1.100],[2.717,0.800],[2.733,0.800],[2.750,0.800],[2.767,0.700],[2.783,0.800],[2.800,0.700],[2.817,0.500],[2.833,0.700],[2.850,0.700],[2.867,0.800]
  ]
};

// Debug-Button Funktion: Rohdatensatz injizieren und auswerten
document.getElementById('debugRohBtn').onclick = function() {
  let sel = document.getElementById('debugRohDropdown').value;
  let v0 = parseFloat(document.getElementById('debugV0Input').value) || 0;
  // Schwellenwerte wie bei Messung starten übernehmen
  decelThreshold = parseFloat(document.getElementById('decelThreshold').value);
  stopThreshold = parseFloat(document.getElementById('stopThreshold').value);
  let rohdaten = debugRohdaten[sel];
  if (!rohdaten || rohdaten.length === 0) {
    alert('Rohdatensatz leer oder nicht gefunden.');
    return;
  }
  // accData wie bei Messung starten befüllen
  accData = rohdaten.map(([t,a]) => ({ t: t*1000, relT: t, a: a }));
  // Trigger- und Statusvariablen zurücksetzen
  trigger1Reached = false;
  trigger2Reached = false;
  postStopTimeout = null;
  stopTime = null;
  measuring = false;
  // Anfangsgeschwindigkeit für die Auswertung setzen
  window.debugV0Override = v0;
  // Hauptfunktion aufrufen
  processMeasurement();
};

// Debug-Version von processMeasurement, die v0 als Parameter nimmt
function processMeasurementDebug(v0) {
  // --- Triggerpunkte im Datenarray suchen (erst jetzt, nicht während Messung!) ---
  let idx1 = -1, t1 = null, a1 = null;
  for (let i = 0; i < accData.length; i++) {
    if (Math.abs(accData[i].a) >= decelThreshold) {
      t1 = accData[i].relT;
      a1 = accData[i].a;
      idx1 = i;
      break;
    }
  }
  let idx2 = -1, t2 = null, a2 = null;
  for (let i = idx1 > 0 ? idx1 : 1; i < accData.length; i++) {
    let prev = accData[i-1], curr = accData[i];
    if (Math.abs(curr.a) < stopThreshold) {
      t2 = curr.relT;
      a2 = curr.a;
      idx2 = i;
      break;
    }
    if (Math.sign(prev.a) !== Math.sign(curr.a)) {
      t2 = prev.relT;
      a2 = prev.a;
      idx2 = i-1;
      break;
    }
  }
  if (t1 === null || t2 === null) {
    if (document.getElementById('result')) { document.getElementById('result').innerHTML = 'Triggerpunkte konnten nicht gefunden werden.'; }
    return;
  }
  let tStart = Math.max(0, t1 - 1.0);
  let tEnd = t2 + 1.0;
  let data = accData.filter(d => d.relT >= tStart && d.relT <= tEnd);
  let trigger1Point = accData[idx1];
  let trigger2Point = accData[idx2];
  if (!data.some(d => d === trigger1Point)) {
    if (trigger1Point.relT < tStart) {
      data.unshift(trigger1Point);
    } else {
      let insertIdx = data.findIndex(d => d.relT > trigger1Point.relT);
      if (insertIdx === -1) data.push(trigger1Point);
      else data.splice(insertIdx, 0, trigger1Point);
    }
  }
  if (!data.some(d => d === trigger2Point)) {
    if (trigger2Point.relT > tEnd) {
      data.push(trigger2Point);
    } else {
      let insertIdx = data.findIndex(d => d.relT > trigger2Point.relT);
      if (insertIdx === -1) data.push(trigger2Point);
      else data.splice(insertIdx, 0, trigger2Point);
    }
  }
  data.forEach(d => { delete d._trigger1; delete d._trigger2; });
  trigger1Point._trigger1 = true;
  trigger2Point._trigger2 = true;
  if (data.length === 0) {
    if (document.getElementById('result')) { document.getElementById('result').innerHTML = 'Keine Messdaten im Auswertebereich.'; }
    return;
  }
  let t0 = data[0].relT;
  let t_beg = t1 - tStart;
  let t_end = t2 - tStart;
  let plotData = data.map(d => {
    let tNorm = d.relT - t0;
    let obj = { t: tNorm, a: d.a };
    if (d._trigger1) obj._trigger1 = true;
    if (d._trigger2) obj._trigger2 = true;
    return obj;
  });
  let idx_beg = plotData.findIndex(d => d._trigger1);
  let idx_end = plotData.findIndex(d => d._trigger2);
  if (idx_beg < 0) idx_beg = 0;
  if (idx_end < 0) idx_end = plotData.length-1;
  let brakeDataRaw = plotData.slice(idx_beg, idx_end+1);
  function smoothCurve(arr, windowSize) {
    let res = [];
    for (let i = 0; i < arr.length; i++) {
      if (i === 0 || i === arr.length-1) {
        res.push(arr[i].a);
      } else {
        let from = Math.max(0, i - windowSize);
        let to = Math.min(arr.length-1, i + windowSize);
        let sum = 0, cnt = 0;
        for (let j = from; j <= to; j++) {
          sum += arr[j].a; cnt++;
        }
        res.push(sum / cnt);
      }
    }
    return res;
  }
  let brakeDataSmooth = plotData.map((d, i) => {
    if (i < idx_beg || i > idx_end) {
      return { t: d.t, a: d.a, _trigger1: d._trigger1, _trigger2: d._trigger2 };
    } else {
      let arr = plotData.slice(idx_beg, idx_end+1);
      let smoothA = smoothCurve(arr, 2)[i-idx_beg];
      return { t: d.t, a: smoothA, _trigger1: d._trigger1, _trigger2: d._trigger2 };
    }
  });
  function integrateBrake(data, startSpeed) {
    let v = [startSpeed];
    let s = 0;
    for (let i = 1; i < data.length; i++) {
      let dt = data[i].t - data[i-1].t;
      if (dt < 0) dt = 0;
      let aVal = Math.abs(data[i].a);
      v[i] = v[i-1] - aVal * dt;
      if (v[i] < 0) {
        let frac = v[i-1] / (v[i-1] - v[i]);
        let tZero = data[i-1].t + frac * (data[i].t - data[i-1].t);
        s += (v[i-1] + 0) / 2 * (tZero - data[i-1].t);
        return { s, v };
      }
      s += (v[i-1] + v[i]) / 2 * dt;
    }
    return { s, v };
  }
  let resRaw = integrateBrake(brakeDataRaw, v0);
  let resSmooth = integrateBrake(brakeDataSmooth, v0);
  let meanA = 0;
  if (brakeDataSmooth.length > 1) {
    let sum = 0, tSum = 0;
    for (let i = 1; i < brakeDataSmooth.length; i++) {
      let dt = brakeDataSmooth[i].t - brakeDataSmooth[i-1].t;
      if (dt < 0) dt = 0;
      sum += Math.abs(brakeDataSmooth[i].a) * dt;
      tSum += dt;
    }
    meanA = tSum > 0 ? sum / tSum : 0;
  }
  let vergleichsweg = meanA > 0 ? (Math.pow(v0,2)/(2*meanA)) : 0;
  let brakeTime = (t_end - t_beg);
  let time = brakeTime.toFixed(2);
  if (document.getElementById('result')) {
    document.getElementById('result').innerHTML =
      `<b>Debug-Auswertung beendet!</b><br>Benötigte Zeit: ${time} s<br>Startgeschwindigkeit: ${v0.toFixed(2)} m/s` +
      `<br>Mittlere Verzögerung: ${meanA.toFixed(2)} m/s²` +
      `<br><span style='color:#888;'>Vergleichsbremsweg (konstant): ${vergleichsweg.toFixed(2)} m</span>` +
      `<br><span style='color:#888;'>Bremsweg (ungeglättet): ${resRaw.s.toFixed(2)} m</span>` +
      `<br><span style='color:#888;'>Bremsweg (geglättet): ${resSmooth.s.toFixed(2)} m</span>` +
      `<div style='margin-top:1em;'><b>Ungeglättet:</b></div>`;
  }
  let canvasRaw = document.createElement('canvas');
  canvasRaw.width = 320;
  canvasRaw.height = 140;
  showAccPlot(plotData, false, {
    tThreshStart: t_beg,
    tThreshEnd: t_end
  }, canvasRaw);
  if (document.getElementById('result')) { document.getElementById('result').appendChild(canvasRaw); }
  if (document.getElementById('result')) {
    document.getElementById('result').innerHTML += `<div style='margin-top:1em;'><b>Geglättet:</b></div>`;
  }
  let canvasSmooth = document.createElement('canvas');
  canvasSmooth.width = 320;
  canvasSmooth.height = 140;
  showAccPlot(brakeDataSmooth, false, {
    tThreshStart: brakeDataSmooth.find(d=>d._trigger1)?.t ?? brakeDataSmooth[0].t,
    tThreshEnd: brakeDataSmooth.find(d=>d._trigger2)?.t ?? brakeDataSmooth[brakeDataSmooth.length-1].t
  }, canvasSmooth);
  if (document.getElementById('result')) { document.getElementById('result').appendChild(canvasSmooth); }
  if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Debug-Auswertung abgeschlossen.'; }
}
// --- DEBUG: Testfunktion für synthetische Sinus-Messung ---
function debugTestSinusMessung() {
  let v0 = 1.0; // m/s
  let peakA = 5.0; // m/s²
  let period = 1.0; // s
  let dt = 0.02; // 50 Hz
  let tMax = 2.0; // 2s
  let decelThreshold = 2.0;
  let stopThreshold = 0.3;
  let accData = [];
  for (let t = 0; t <= tMax; t += dt) {
    let a = peakA * Math.sin(2 * Math.PI * t / period);
    accData.push({ t: t*1000, relT: t, a: a });
  }
  let idx1 = -1, t1 = null, a1 = null;
  for (let i = 0; i < accData.length; i++) {
    if (Math.abs(accData[i].a) >= decelThreshold) {
      t1 = accData[i].relT;
      a1 = accData[i].a;
      idx1 = i;
      break;
    }
  }
  let idx2 = -1, t2 = null, a2 = null;
  for (let i = idx1 > 0 ? idx1 : 1; i < accData.length; i++) {
    let prev = accData[i-1], curr = accData[i];
    if (Math.abs(curr.a) < stopThreshold) {
      t2 = curr.relT;
      a2 = curr.a;
      idx2 = i;
      break;
    }
    if (Math.sign(prev.a) !== Math.sign(curr.a)) {
      t2 = prev.relT;
      a2 = prev.a;
      idx2 = i-1;
      break;
    }
  }
  let tStart = Math.max(0, t1 - 1.0);
  let tEnd = t2 + 1.0;
  let data = accData.filter(d => d.relT >= tStart && d.relT <= tEnd);
  let trigger1Point = accData[idx1];
  let trigger2Point = accData[idx2];
  if (!data.some(d => d === trigger1Point)) {
    if (trigger1Point.relT < tStart) {
      data.unshift(trigger1Point);
    } else {
      let insertIdx = data.findIndex(d => d.relT > trigger1Point.relT);
      if (insertIdx === -1) data.push(trigger1Point);
      else data.splice(insertIdx, 0, trigger1Point);
    }
  }
  if (!data.some(d => d === trigger2Point)) {
    if (trigger2Point.relT > tEnd) {
      data.push(trigger2Point);
    } else {
      let insertIdx = data.findIndex(d => d.relT > trigger2Point.relT);
      if (insertIdx === -1) data.push(trigger2Point);
      else data.splice(insertIdx, 0, trigger2Point);
    }
  }
  data.forEach(d => { delete d._trigger1; delete d._trigger2; });
  trigger1Point._trigger1 = true;
  trigger2Point._trigger2 = true;
  let t0 = data[0].relT;
  let plotData = data.map(d => {
    let tNorm = d.relT - t0;
    let obj = { t: tNorm, a: d.a };
    if (d._trigger1) obj._trigger1 = true;
    if (d._trigger2) obj._trigger2 = true;
    return obj;
  });
  showAccPlot(plotData, false, {
    tThreshStart: t1 - tStart,
    tThreshEnd: t2 - tStart
  });
}
document.getElementById('debugSinusBtn').onclick = debugTestSinusMessung;
let accBuffer = [];
let accData = [];
let trigger1Reached = false;
let trigger2Reached = false;
let postStopTimeout = null;
let startTime = null;
let stopTime = null;
let decelThreshold = 2;
let stopThreshold = 0.3;
let direction = 'y';
let useGravity = false; // UI-Status
let measuring = false;
let measuringUseGravity = false; // Für die laufende Messung
let results = [];
let accHistories = [];
let plotPNGs = [];
let postStopActive = false;
let postStopStart = null;
const ACC_BUFFER_SEC = 1.0; // 1s Vorlauf
// rotateVector Dummy, falls nicht definiert
if (typeof rotateVector !== 'function') {
  function rotateVector(x, y, z, wx, wy, wz) {
    return { x: x, y: y, z: z };
  }
}
// useGravity beim Laden auf den Zustand des Kontrollkästchens setzen
useGravity = document.getElementById('gravityToggle').checked;
// Event-Listener für das Kontrollkästchen
document.getElementById('gravityToggle').addEventListener('change', function() {
  useGravity = this.checked;
});
document.getElementById('startBtn').onclick = function() {
  decelThreshold = parseFloat(document.getElementById('decelThreshold').value);
  stopThreshold = parseFloat(document.getElementById('stopThreshold').value);
  direction = document.getElementById('direction').value;
  measuring = true;
  measuringUseGravity = useGravity; // Für diese Messung merken
  let now = performance.now();
  startTime = now;
  // accData: Puffer übernehmen, relT auf 0 setzen (relativ zum Messbeginn)
  accData = accBuffer.map(d => ({ t: d.t, relT: (d.t - now) / 1000, a: d.a }));
  trigger1Reached = false;
  trigger2Reached = false;
  postStopTimeout = null;
  stopTime = null;
  if (document.getElementById('result')) { document.getElementById('result').innerHTML = ''; }
  if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Messdatenerfassung läuft...'; }
};

document.getElementById('stopBtn').onclick = function() {
  measuring = false;
  startTime = null;
  stopTime = null;
  accBuffer = [];
  accData = [];
  trigger1Reached = false;
  trigger2Reached = false;
  if (document.getElementById('result')) { document.getElementById('result').innerHTML = ''; }
  if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Messung gestoppt. Werte können angepasst werden.'; }
  if (document.getElementById('acceleration')) { document.getElementById('acceleration').innerHTML = 'Verzögerung: 0 m/s²'; }
};

document.getElementById('clearBtn').onclick = function() {
  results = [];
  updateResultsList();
};

function updateResultsList() {
  const listDiv = document.getElementById('resultsList');
  if (results.length === 0) {
    listDiv.innerHTML = '';
    return;
  }
  let html = '<b>Messungen:</b>';
  results.forEach((r, i) => {
    // Nummerierung: älteste Messung = 1, neueste = results.length
    const messungsNummer = results.length - i;
    // Zeitstempel erzeugen (beim ersten Mal speichern)
    if (!r.timestamp) {
      const now = new Date();
      const datum = now.toLocaleDateString('de-DE');
      const uhrzeit = now.toLocaleTimeString('de-DE');
      r.timestamp = `${datum}; ${uhrzeit} Uhr`;
    }
    html += `<div style='margin-bottom:1.5em;padding:0.5em;background:#f8f8f8;border-radius:0.5em;'>`;
    html += `<b>Messung ${messungsNummer} (${r.timestamp})</b>: Zeit: ${r.time}s, Startgeschw.: ${r.startSpeed}m/s, Mittlere Verzögerung: ${r.meanA} m/s², Bremsweg: ${r.distance}m`;
    html += `<br><span style='color:#888;'>Vergleichsbremsweg (a konst.): ${r.vergleichsweg} m</span>`;
    html += `<br><span style='color:#888;'>Bremsweg (normierte Kurve): ${r.normBremsweg} m</span>`;
    html += `<br><span class='plotimg' id='plotimg${i}'></span>`;
    html += `</div>`;
  });
  listDiv.innerHTML = html;
  // Nach dem Einfügen: für jede Messung beide Plots erzeugen
  results.forEach((r, i) => {
    if (accHistories[i]) {
      let imgDiv = document.getElementById('plotimg'+i);
      if (!imgDiv) return;
      // Ungeglättet
      let canvasRaw = document.createElement('canvas');
      canvasRaw.width = 320;
      canvasRaw.height = 140;
      showAccPlot(accHistories[i].raw, false, {
        tThreshStart: accHistories[i].raw.find(d=>d._trigger1)?.t ?? accHistories[i].raw[0].t,
        tThreshEnd: accHistories[i].raw.find(d=>d._trigger2)?.t ?? accHistories[i].raw[accHistories[i].raw.length-1].t
      }, canvasRaw);
      let labelRaw = document.createElement('div');
      labelRaw.innerHTML = '<b>Ungeglättet</b>';
      imgDiv.appendChild(labelRaw);
      imgDiv.appendChild(canvasRaw);
      // Geglättet
      let canvasSmooth = document.createElement('canvas');
      canvasSmooth.width = 320;
      canvasSmooth.height = 140;
      showAccPlot(accHistories[i].smooth, false, {
        tThreshStart: accHistories[i].smooth.find(d=>d._trigger1)?.t ?? accHistories[i].smooth[0].t,
        tThreshEnd: accHistories[i].smooth.find(d=>d._trigger2)?.t ?? accHistories[i].smooth[accHistories[i].smooth.length-1].t
      }, canvasSmooth);
      let labelSmooth = document.createElement('div');
      labelSmooth.innerHTML = '<b>Geglättet</b>';
      imgDiv.appendChild(labelSmooth);
      imgDiv.appendChild(canvasSmooth);
    }
  });
}

// --- Messdatenerfassung ---
window.addEventListener('devicemotion', function(event) {
  // --- Immer aktuellen Beschleunigungswert berechnen und anzeigen ---
  let accRaw = useGravity ? event.accelerationIncludingGravity : event.acceleration;
  if (!accRaw) return;
  let wx = parseFloat(document.getElementById('winkelX').value) || 0;
  let wy = parseFloat(document.getElementById('winkelY').value) || 0;
  let wz = parseFloat(document.getElementById('winkelZ').value) || 0;
  let vec = rotateVector(accRaw.x || 0, accRaw.y || 0, accRaw.z || 0, wx, wy, wz);
  let a = 0;
  let dir = direction;
  if (dir === 'betrag') {
    a = Math.sqrt(vec.x*vec.x + vec.y*vec.y + vec.z*vec.z);
  } else {
    a = vec[dir] || 0;
  }
  let now = performance.now();
  // Buffer auf 1s begrenzen
  accBuffer.push({t: now, relT: 0, a: a});
  while (accBuffer.length > 0 && (now - accBuffer[0].t) > 1100) accBuffer.shift();
  // relT im Buffer aktualisieren (relativ zu jetzt)
  accBuffer.forEach(d => d.relT = (d.t - now) / 1000);
  // Anzeige immer aktualisieren
  document.getElementById('acceleration').innerHTML = `Verzögerung${useGravity ? ' inkl. Gravitation' : ''}: ${a.toFixed(2)} m/s²`;

  // --- Messung läuft? Dann Messdaten erfassen ---
  if (measuring) {
    let acc = measuringUseGravity ? event.accelerationIncludingGravity : event.acceleration;
    if (!acc) return;
    let wxM = parseFloat(document.getElementById('winkelX').value) || 0;
    let wyM = parseFloat(document.getElementById('winkelY').value) || 0;
    let wzM = parseFloat(document.getElementById('winkelZ').value) || 0;
    let vecM = rotateVector(acc.x || 0, acc.y || 0, acc.z || 0, wxM, wyM, wzM);
    let aM = 0;
    if (direction === 'betrag') {
      aM = Math.sqrt(vecM.x*vecM.x + vecM.y*vecM.y + vecM.z*vecM.z);
    } else {
      aM = vecM[direction] || 0;
    }
    let relTime = (now - startTime) / 1000;
    accData.push({t: now, relT: relTime, a: aM});

    // Trigger 1 prüfen (erstes Überschreiten decelThreshold)
    if (!trigger1Reached && Math.abs(aM) >= decelThreshold) {
      trigger1Reached = true;
      if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Trigger 1 erreicht, warte auf Trigger 2...'; }
    }

    // Trigger 2 prüfen (erstes Unterschreiten stopThreshold oder Vorzeichenwechsel nach Trigger 1)
    if (trigger1Reached && !trigger2Reached && accData.length > 1) {
      let prev = accData[accData.length-2];
      let curr = accData[accData.length-1];
      if (Math.abs(curr.a) < stopThreshold) {
        trigger2Reached = true;
        if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Trigger 2 erreicht, Nachlauf...'; }
        if (!postStopTimeout) {
          postStopTimeout = setTimeout(() => {
            measuring = false;
            stopTime = performance.now();
            processMeasurement();
          }, 1000);
        }
      } else if (Math.sign(prev.a) !== Math.sign(curr.a)) {
        trigger2Reached = true;
        if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Trigger 2 erreicht (Vorzeichenwechsel), Nachlauf...'; }
        if (!postStopTimeout) {
          postStopTimeout = setTimeout(() => {
            measuring = false;
            stopTime = performance.now();
            processMeasurement();
          }, 1000);
        }
      }
    }
  }
});

// --- Messdatenauswertung und Bremsweg-Berechnung ---
function processMeasurement() {
  // --- Triggerpunkte im Datenarray suchen (erst jetzt, nicht während Messung!) ---
  // 1. Trigger: erster Messwert, der Betrag >= decelThreshold
  let idx1 = -1, t1 = null, a1 = null;
  for (let i = 0; i < accData.length; i++) {
    if (Math.abs(accData[i].a) >= decelThreshold) {
      t1 = accData[i].relT;
      a1 = accData[i].a;
      idx1 = i;
      break;
    }
  }
  // 2. Trigger: erster Messwert nach idx1, der Betrag < stopThreshold oder Vorzeichenwechsel
  let idx2 = -1, t2 = null, a2 = null;
  for (let i = idx1 > 0 ? idx1 : 1; i < accData.length; i++) {
    let prev = accData[i-1], curr = accData[i];
    if (Math.abs(curr.a) < stopThreshold) {
      t2 = curr.relT;
      a2 = curr.a;
      idx2 = i;
      break;
    }
    if (Math.sign(prev.a) !== Math.sign(curr.a)) {
      t2 = prev.relT;
      a2 = prev.a;
      idx2 = i-1;
      break;
    }
  }
  if (t1 === null || t2 === null) {
    if (document.getElementById('result')) { document.getElementById('result').innerHTML = 'Triggerpunkte konnten nicht gefunden werden.'; }
    return;
  }
  // Zeitbereich: 1s vor Trigger1 bis 1s nach Trigger2 (relativ zu Messbeginn)
  let tStart = Math.max(0, t1 - 1.0);
  let tEnd = t2 + 1.0;
  // Schneide Messdaten auf diesen Bereich zu, stelle aber sicher, dass die Triggerpunkte idx1 und idx2 IMMER enthalten sind
  let data = accData.filter(d => d.relT >= tStart && d.relT <= tEnd);
  // Triggerpunkte (echte Messwerte) holen
  let trigger1Point = accData[idx1];
  let trigger2Point = accData[idx2];
  // Falls Triggerpunkte nicht im Bereich enthalten sind, füge sie ein (an den passenden Stellen)
  if (!data.some(d => d === trigger1Point)) {
    // An den Anfang einfügen, falls davor
    if (trigger1Point.relT < tStart) {
      data.unshift(trigger1Point);
    } else {
      // An richtiger Stelle einsortieren
      let insertIdx = data.findIndex(d => d.relT > trigger1Point.relT);
      if (insertIdx === -1) data.push(trigger1Point);
      else data.splice(insertIdx, 0, trigger1Point);
    }
  }
  if (!data.some(d => d === trigger2Point)) {
    if (trigger2Point.relT > tEnd) {
      data.push(trigger2Point);
    } else {
      let insertIdx = data.findIndex(d => d.relT > trigger2Point.relT);
      if (insertIdx === -1) data.push(trigger2Point);
      else data.splice(insertIdx, 0, trigger2Point);
    }
  }
  // Marker nur an echten Triggerpunkten setzen, alle anderen Marker entfernen
  data.forEach(d => { delete d._trigger1; delete d._trigger2; });
  trigger1Point._trigger1 = true;
  trigger2Point._trigger2 = true;

  // Zeitachse für Plot und Integration: relT auf 0 normieren
  if (data.length === 0) {
    if (document.getElementById('result')) { document.getElementById('result').innerHTML = 'Keine Messdaten im Auswertebereich.'; }
    return;
  }
  let t0 = data[0].relT;
  // Triggerpunkte im normierten Zeitbereich bestimmen
  let t_beg = t1 - tStart;
  let t_end = t2 - tStart;
  // plotData: Marker nur an echten Triggerpunkten
  let plotData = data.map(d => {
    let tNorm = d.relT - t0;
    let obj = { t: tNorm, a: d.a };
    if (d._trigger1) obj._trigger1 = true;
    if (d._trigger2) obj._trigger2 = true;
    return obj;
  });
  // Index im Datenarray für Start und Ende
  let idx_beg = plotData.findIndex(d => d._trigger1);
  let idx_end = plotData.findIndex(d => d._trigger2);
  if (idx_beg < 0) idx_beg = 0;
  if (idx_end < 0) idx_end = plotData.length-1;

  // --- Ungeglättete Beschleunigungskurve für das Intervall ---
  let brakeDataRaw = plotData.slice(idx_beg, idx_end+1);

  // --- Glättung (moving average, aber Endpunkte bleiben erhalten) ---
  function smoothCurve(arr, windowSize) {
    let res = [];
    for (let i = 0; i < arr.length; i++) {
      if (i === 0 || i === arr.length-1) {
        res.push(arr[i].a); // Endpunkte nicht glätten
      } else {
        let from = Math.max(0, i - windowSize);
        let to = Math.min(arr.length-1, i + windowSize);
        let sum = 0, cnt = 0;
        for (let j = from; j <= to; j++) {
          sum += arr[j].a; cnt++;
        }
        res.push(sum / cnt);
      }
    }
    return res;
  }
  // Glättung nur zwischen Triggerpunkten, davor und danach Originalwerte
  let brakeDataSmooth = plotData.map((d, i) => {
    if (i < idx_beg || i > idx_end) {
      // Vor erstem oder nach letztem Triggerpunkt: Originalwert
      return { t: d.t, a: d.a, _trigger1: d._trigger1, _trigger2: d._trigger2 };
    } else {
      // Im Bremsbereich: geglättet
      let arr = plotData.slice(idx_beg, idx_end+1);
      let smoothA = smoothCurve(arr, 2)[i-idx_beg];
      return { t: d.t, a: smoothA, _trigger1: d._trigger1, _trigger2: d._trigger2 };
    }
  });

  // --- Bremsweg-Berechnung ---
  function integrateBrake(data, startSpeed) {
    let v = [startSpeed];
    let s = 0;
    for (let i = 1; i < data.length; i++) {
      let dt = data[i].t - data[i-1].t;
      if (dt < 0) dt = 0; // Sicherheit
      let aVal = Math.abs(data[i].a);
      v[i] = v[i-1] - aVal * dt;
      if (v[i] < 0) {
        // Interpolieren, wann v=0 erreicht wurde
        let frac = v[i-1] / (v[i-1] - v[i]);
        let tZero = data[i-1].t + frac * (data[i].t - data[i-1].t);
        s += (v[i-1] + 0) / 2 * (tZero - data[i-1].t);
        return { s, v };
      }
      s += (v[i-1] + v[i]) / 2 * dt;
    }
    return { s, v };
  }

  // Startgeschwindigkeit: Integration rückwärts bis t_beg
  let v0;
  if (typeof window.debugV0Override === 'number') {
    v0 = window.debugV0Override;
    // Nach Auswertung wieder löschen
    setTimeout(()=>{window.debugV0Override=undefined;},0);
  } else {
    v0 = 0;
    for (let i = idx_beg-1; i >= 0; i--) {
      let dt = plotData[i+1].t - plotData[i].t;
      if (dt < 0) dt = 0;
      v0 += Math.abs(plotData[i].a) * dt;
    }
  }

  // Ungeglättet
  let resRaw = integrateBrake(brakeDataRaw, v0);
  // Geglättet
  let resSmooth = integrateBrake(brakeDataSmooth, v0);

  // Mittelwert der Verzögerung (im Intervall)
  let meanA = 0;
  if (brakeDataSmooth.length > 1) {
    let sum = 0, tSum = 0;
    for (let i = 1; i < brakeDataSmooth.length; i++) {
      let dt = brakeDataSmooth[i].t - brakeDataSmooth[i-1].t;
      if (dt < 0) dt = 0;
      sum += Math.abs(brakeDataSmooth[i].a) * dt;
      tSum += dt;
    }
    meanA = tSum > 0 ? sum / tSum : 0;
  }
  let vergleichsweg = meanA > 0 ? (Math.pow(v0,2)/(2*meanA)) : 0;

  // Ausgabe
  let brakeTime = (t_end - t_beg);
  let time = brakeTime.toFixed(2);
  if (document.getElementById('result')) {
    document.getElementById('result').innerHTML =
      `<b>Messung beendet!</b><br>Benötigte Zeit: ${time} s<br>Startgeschwindigkeit: ${v0.toFixed(2)} m/s` +
      `<br>Mittlere Verzögerung: ${meanA.toFixed(2)} m/s²` +
      `<br><span style='color:#888;'>Vergleichsbremsweg (konstant): ${vergleichsweg.toFixed(2)} m</span>` +
      `<br><span style='color:#888;'>Bremsweg (ungeglättet): ${resRaw.s.toFixed(2)} m</span>` +
      `<br><span style='color:#888;'>Bremsweg (geglättet): ${resSmooth.s.toFixed(2)} m</span>` +
      `<div style='margin-top:1em;'><b>Ungeglättet:</b></div>`;
  }
  // Ungeglätteter Plot
  let canvasRaw = document.createElement('canvas');
  canvasRaw.width = 320;
  canvasRaw.height = 140;
  showAccPlot(plotData, false, {
    tThreshStart: t_beg,
    tThreshEnd: t_end
  }, canvasRaw);
  // Entferne NUR die Anzeige des grauen Kastens mit den aktuellen Messwerten
  // Die Daten- und Canvas-Erstellung bleibt erhalten
  if (document.getElementById('result')) { document.getElementById('result').innerHTML = ''; }
  if (document.getElementById('result')) { document.getElementById('result').appendChild(canvasRaw); }
  if (document.getElementById('result')) {
    document.getElementById('result').innerHTML += `<div style='margin-top:1em;'><b>Geglättet:</b></div>`;
  }
  // Geglätteter Plot
  let canvasSmooth = document.createElement('canvas');
  canvasSmooth.width = 320;
  canvasSmooth.height = 140;
  showAccPlot(brakeDataSmooth, false, {
    tThreshStart: brakeDataSmooth.find(d=>d._trigger1)?.t ?? brakeDataSmooth[0].t,
    tThreshEnd: brakeDataSmooth.find(d=>d._trigger2)?.t ?? brakeDataSmooth[brakeDataSmooth.length-1].t
  }, canvasSmooth);
  if (document.getElementById('result')) { document.getElementById('result').appendChild(canvasSmooth); }

  if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Stillstand erkannt.'; }

  // Für Historie beide Kurven speichern
  // Ergebnisse in die Historie einfügen (neueste zuerst)
  plotPNGs.unshift(canvasRaw.toDataURL('image/png'));
accHistories.unshift({raw: plotData.map(d => ({t: d.t, a: d.a, _trigger1: d._trigger1, _trigger2: d._trigger2})), smooth: brakeDataSmooth});
results.unshift({
  time: time,
  startSpeed: v0.toFixed(2),
  distance: resSmooth.s.toFixed(2),
  vergleichsweg: vergleichsweg.toFixed(2),
  meanA: meanA.toFixed(2),
  normBremsweg: resSmooth.s.toFixed(2)
});
  updateResultsList();
}

// --- Plot-Funktion für Verzögerung über Zeit
function showAccPlot(data, returnPNG=false, opts={}, canvasOverride) {
  // opts: { tThreshStart, tThreshEnd }
  let plotDiv = document.getElementById('result');
  let w = 320, h = 140, pad = 40;
  let canvas = canvasOverride || document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  canvas.style.marginTop = '1em';
  let ctx = canvas.getContext('2d');
  // Zeitbereich bestimmen
  let tStart = 0;
  let tEnd = data[data.length-1].t;
  // Wertebereich bestimmen
  let amin = Math.min(...data.map(d=>d.a));
  let amax = Math.max(...data.map(d=>d.a));
  if (amin === amax) { amin -= 1; amax += 1; }
  // y=0 (a=0) bestimmen
  let y0 = h-pad - (h-2*pad) * ((0-amin)/(amax-amin));

  // --- Achsen zeichnen ---
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  // x-Achse (a=0)
  ctx.moveTo(pad, y0);
  ctx.lineTo(w-pad, y0);
  // y-Achse
  ctx.moveTo(pad, h-pad);
  ctx.lineTo(pad, pad);
  ctx.stroke();

  // --- Achsenbeschriftungen ---
  ctx.fillStyle = '#222';
  ctx.font = '12px Segoe UI';
  ctx.textAlign = 'center';
  // X-Achse
  ctx.fillText('Zeit (s)', w/2, h-4);
  // Y-Achse: ganz links oben an der Achse, horizontal
  ctx.textAlign = 'left';
  ctx.fillText('a (m/s²)', pad-32, pad-8);

  // --- Wertebereichsbeschriftung ---
  ctx.fillStyle = '#444';
  ctx.font = '12px Segoe UI';
  ctx.textAlign = 'right';
  ctx.fillText(amin.toFixed(1), pad-5, h-pad);
  ctx.fillText(amax.toFixed(1), pad-5, pad+5);
  // X-Achse Werte
  ctx.textAlign = 'center';
  ctx.font = '12px Segoe UI';
  ctx.fillText((tStart).toFixed(2), pad, h-pad+15);
  ctx.fillText((tEnd).toFixed(2), w-pad, h-pad+15);

  // --- Plot der Kurve abschnittsweise (grau/rot/grau) ---
  const graphLineWidth = 2;
  ctx.lineWidth = graphLineWidth;
  // Triggerpunkte aus Datenarray extrahieren
  let tEvalStart = undefined, tEvalEnd = undefined;
  let idx1 = data.findIndex(d => d._trigger1);
  let idx2 = data.findIndex(d => d._trigger2);
  if (idx1 >= 0) tEvalStart = data[idx1].t;
  if (idx2 >= 0) tEvalEnd = data[idx2].t;

  // Zeichne abschnittsweise
  let lastColor = null;
  ctx.beginPath();
  for (let i = 0; i < data.length-1; i++) {
    let t0 = data[i].t, t1 = data[i+1].t;
    let a0 = data[i].a, a1 = data[i+1].a;
    let x0 = pad + (w-2*pad) * ((t0-tStart)/(tEnd-tStart));
    let y0p = h-pad - (h-2*pad) * ((a0-amin)/(amax-amin));
    let x1 = pad + (w-2*pad) * ((t1-tStart)/(tEnd-tStart));
    let y1p = h-pad - (h-2*pad) * ((a1-amin)/(amax-amin));

    // Abschnittsfarbe bestimmen
    let segStart = t0, segEnd = t1;
    let segColor = '#bbb';
    if (tEvalStart !== undefined && tEvalEnd !== undefined) {
      if (segEnd <= tEvalStart || segStart >= tEvalEnd) {
        segColor = '#bbb';
      } else if (segStart >= tEvalStart && segEnd <= tEvalEnd) {
        segColor = '#e84118';
      } else {
        // Segment schneidet einen Schwellenwert: splitten und beide Teile zeichnen
        if (segStart < tEvalStart && segEnd > tEvalStart && segEnd <= tEvalEnd) {
          // Split bei tEvalStart
          let frac = (tEvalStart - segStart) / (segEnd - segStart);
          let xSplit = x0 + frac * (x1 - x0);
          let ySplit = y0p + frac * (y1p - y0p);
          // Grau bis tEvalStart
          ctx.strokeStyle = '#bbb';
          ctx.beginPath();
          ctx.moveTo(x0, y0p);
          ctx.lineTo(xSplit, ySplit);
          ctx.stroke();
          // Rot ab tEvalStart
          ctx.strokeStyle = '#e84118';
          ctx.beginPath();
          ctx.moveTo(xSplit, ySplit);
          ctx.lineTo(x1, y1p);
          ctx.stroke();
          continue;
        } else if (segStart >= tEvalStart && segStart < tEvalEnd && segEnd > tEvalEnd) {
          // Split bei tEvalEnd
          let frac = (tEvalEnd - segStart) / (segEnd - segStart);
          let xSplit = x0 + frac * (x1 - x0);
          let ySplit = y0p + frac * (y1p - y0p);
          // Rot bis tEvalEnd
          ctx.strokeStyle = '#e84118';
          ctx.beginPath();
          ctx.moveTo(x0, y0p);
          ctx.lineTo(xSplit, ySplit);
          ctx.stroke();
          // Grau ab tEvalEnd
          ctx.strokeStyle = '#bbb';
          ctx.beginPath();
          ctx.moveTo(xSplit, ySplit);
          ctx.lineTo(x1, y1p);
          ctx.stroke();
          continue;
        } else if (segStart < tEvalStart && segEnd > tEvalEnd) {
          // Split bei beiden Schwellenwerten
          let frac1 = (tEvalStart - segStart) / (segEnd - segStart);
          let xSplit1 = x0 + frac1 * (x1 - x0);
          let ySplit1 = y0p + frac1 * (y1p - y0p);
          let frac2 = (tEvalEnd - segStart) / (segEnd - segStart);
          let xSplit2 = x0 + frac2 * (x1 - x0);
          let ySplit2 = y0p + frac2 * (y1p - y0p);
          // Grau bis tEvalStart
          ctx.strokeStyle = '#bbb';
          ctx.beginPath();
          ctx.moveTo(x0, y0p);
          ctx.lineTo(xSplit1, ySplit1);
          ctx.stroke();
          // Rot zwischen tEvalStart und tEvalEnd
          ctx.strokeStyle = '#e84118';
          ctx.beginPath();
          ctx.moveTo(xSplit1, ySplit1);
          ctx.lineTo(xSplit2, ySplit2);
          ctx.stroke();
          // Grau ab tEvalEnd
          ctx.strokeStyle = '#bbb';
          ctx.beginPath();
          ctx.moveTo(xSplit2, ySplit2);
          ctx.lineTo(x1, y1p);
          ctx.stroke();
          continue;
        }
      }
    } else if (tEvalStart !== undefined && segStart >= tEvalStart) {
      segColor = '#e84118';
    }
    ctx.strokeStyle = segColor;
    ctx.beginPath();
    ctx.moveTo(x0, y0p);
    ctx.lineTo(x1, y1p);
    ctx.stroke();
  }

  // --- Schwellenwert-Marker und Zeitmarken ---
  // Marker für Start (grün)
  if (tEvalStart !== undefined) {
    let idx = data.findIndex(d => d._trigger1);
    if (idx >= 0) {
      let d = data[idx];
      let x = pad + (w-2*pad) * ((d.t-tStart)/(tEnd-tStart));
      let y = h-pad - (h-2*pad) * ((d.a-amin)/(amax-amin));
      // Punkt
      ctx.beginPath();
      ctx.arc(x, y, graphLineWidth*2, 0, 2*Math.PI);
      ctx.fillStyle = '#27ae60'; // kräftiges grün
      ctx.fill();
      // Vertikale gepunktete Linie
      ctx.save();
      ctx.setLineDash([4, 4]);
     
      ctx.strokeStyle = '#e84118'; // rot wie Auswertebereich
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, h-pad+18);
      ctx.stroke();
           ctx.setLineDash([]);
      ctx.restore();
      // Zeitwert unter Achse
      ctx.save();
      ctx.font = 'bold 13px Segoe UI';
      ctx.fillStyle = '#e84118';
      ctx.textAlign = 'center';
      ctx.fillText(d.t.toFixed(2) + 's', x, h-pad+32);
      ctx.restore();
    }
  }
  // Marker für Ende (blau)
  if (tEvalEnd !== undefined) {
    let idx = data.findIndex(d => d._trigger2);
    if (idx >= 0) {
      let d = data[idx];
      let x = pad + (w-2*pad) * ((d.t-tStart)/(tEnd-tStart));
      let y = h-pad - (h-2*pad) * ((d.a-amin)/(amax-amin));
      // Punkt
      ctx.beginPath();
      ctx.arc(x, y, graphLineWidth*2, 0, 2*Math.PI);
      ctx.fillStyle = '#0097e6'; // kräftiges blau
      ctx.fill();
      // Vertikale gepunktete Linie
      ctx.save();
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = '#0097e6';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, h-pad+18);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      // Zeitwert unter Achse
      ctx.save();
      ctx.font = 'bold 13px Segoe UI';
      ctx.fillStyle = '#0097e6';
      ctx.textAlign = 'center';
      ctx.fillText(d.t.toFixed(2) + 's', x, h-pad+32);
      ctx.restore();
    }
  }

  if (!returnPNG) {
    if (!canvasOverride) plotDiv.appendChild(canvas);
    return;
  } else {
    return canvas.toDataURL('image/png');
  }
}
// SheetJS für Excel-Export einbinden
let sheetjsLoaded = false;
function loadSheetJS(cb) {
  if (sheetjsLoaded) { cb(); return; }
  let script = document.createElement('script');
  script.src = 'https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js';
  script.onload = function() { sheetjsLoaded = true; cb(); };
  document.body.appendChild(script);
}

document.getElementById('exportBtn').onclick = function() {
  loadSheetJS(function() {
    let wb = XLSX.utils.book_new();
    // Haupttabelle mit Messwerten
    let ws_data = [['Nr','Zeit (s)','Startgeschw. (m/s)','Bremsweg (m)','Vergleichsbremsweg (m)','Mittlere Verzögerung (m/s²)','Bremsweg (normierte Kurve)']];
    results.forEach((r,i)=>{
      ws_data.push([i+1, r.time, r.startSpeed, r.distance, r.vergleichsweg, r.meanA, r.normBremsweg]);
    });
    let ws = XLSX.utils.aoa_to_sheet(ws_data);
    XLSX.utils.book_append_sheet(wb, ws, 'Messungen');

    // Für jeden Datensatz: Rohdaten und geglättete Daten als eigene Sheets
    accHistories.forEach((hist,i)=>{
      // Rohdaten
      if (hist.raw) {
        let rawData = [['Zeit (s)','Verzögerung (m/s²)','Trigger1','Trigger2']];
        hist.raw.forEach(d=>{
          rawData.push([
            typeof d.t === 'number' ? d.t.toFixed(3) : '',
            typeof d.a === 'number' ? d.a.toFixed(3) : '',
            d._trigger1 ? 'X' : '',
            d._trigger2 ? 'X' : ''
          ]);
        });
        let rawSheet = XLSX.utils.aoa_to_sheet(rawData);
        XLSX.utils.book_append_sheet(wb, rawSheet, `Rohdaten${i+1}`);
      }
      // Geglättete Daten
      if (hist.smooth) {
        let smoothData = [['Zeit (s)','Verzögerung (m/s²)','Trigger1','Trigger2']];
        hist.smooth.forEach(d=>{
          smoothData.push([
            typeof d.t === 'number' ? d.t.toFixed(3) : '',
            typeof d.a === 'number' ? d.a.toFixed(3) : '',
            d._trigger1 ? 'X' : '',
            d._trigger2 ? 'X' : ''
          ]);
        });
        let smoothSheet = XLSX.utils.aoa_to_sheet(smoothData);
        XLSX.utils.book_append_sheet(wb, smoothSheet, `Geglättet${i+1}`);
      }
    });
    XLSX.writeFile(wb, 'bremsweg_messungen.xlsx');
  });
};

document.getElementById('calibBtn').onclick = function() {
  // Hole aktuelle Beschleunigung inkl. Gravitation
  let acc = window.lastAccInclGrav;
  if (!acc) {
    alert('Keine Beschleunigungsdaten verfügbar. Bitte das Gerät ruhig halten und kurz warten.');
    return;
  }
  // Berechne Winkel zwischen Beschleunigungsvektor und Z-Achse
  let ax = acc.x || 0;
  let ay = acc.y || 0;
  let az = acc.z || 0;
  let g = Math.sqrt(ax*ax + ay*ay + az*az);
  if (g === 0) {
    alert('Ungültige Sensordaten.');
    return;
  }
  // Winkel zur Z-Achse (in Grad)
  let winkelX = Math.acos(az/g) * 180 / Math.PI;
  if (ax < 0) winkelX = -winkelX;
  document.getElementById('winkelX').value = winkelX.toFixed(1);
};
let breakCalibState = null;
let breakAccs = [];
let breakGravAccs = [];
let breakTimeout = null;
document.getElementById('calibBreakBtn').onclick = function() {
  if (breakCalibState) return;
  breakCalibState = 'waitForAccel';
  breakAccs = [];
  breakGravAccs = [];
  if (breakTimeout) { clearTimeout(breakTimeout); breakTimeout = null; }
  // Schwellenwerte aus den Eingabefeldern holen
  window.breakDecelThreshold = parseFloat(document.getElementById('decelThreshold').value) || 2;
  window.breakStopThreshold = parseFloat(document.getElementById('stopThreshold').value) || 0.3;
  if (document.getElementById('status')) { document.getElementById('status').innerHTML = `Warte auf Bremsbeschleunigung (>${window.breakDecelThreshold} m/s²)...`; }
};

window.lastAccInclGrav = null;
window.addEventListener('devicemotion', function(event) {
  window.lastAccInclGrav = event.accelerationIncludingGravity;
  // Kalibrierung break
  if (breakCalibState === 'waitForAccel') {
    let acc = event.acceleration;
    if (!acc) return;
    let aVec = [acc.x||0, acc.y||0, acc.z||0];
    let aMag = Math.sqrt(aVec[0]*aVec[0]+aVec[1]*aVec[1]+aVec[2]*aVec[2]);
    if (aMag > ((window.breakDecelThreshold !== undefined ? window.breakDecelThreshold : 2))) {
      breakCalibState = 'measureAccel';
      breakAccs = [];
      if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Messe Bremsrichtung...'; }
      if (breakTimeout) { clearTimeout(breakTimeout); breakTimeout = null; }
      breakTimeout = setTimeout(function(){
        breakCalibState = 'waitForStill';
        breakGravAccs = [];
        if (document.getElementById('status')) { document.getElementById('status').innerHTML = `Warte auf Stillstand (<${window.breakStopThreshold !== undefined ? window.breakStopThreshold : 0.2} m/s² für 2s)...`; }
        breakTimeout = null;
      }, 500);
    }
  }
  if (breakCalibState === 'measureAccel') {
    let acc = event.acceleration;
    if (!acc) return;
    breakAccs.push([acc.x||0, acc.y||0, acc.z||0]);
  }
  if (breakCalibState === 'waitForStill') {
    let acc = event.acceleration;
    if (!acc) return;
    let aVec = [acc.x||0, acc.y||0, acc.z||0];
    let aMag = Math.sqrt(aVec[0]*aVec[0]+aVec[1]*aVec[1]+aVec[2]*aVec[2]);
    if (aMag < ((window.breakStopThreshold !== undefined ? window.breakStopThreshold : 0.2))) {
      breakGravAccs.push(window.lastAccInclGrav ? [window.lastAccInclGrav.x||0, window.lastAccInclGrav.y||0, window.lastAccInclGrav.z||0] : [0,0,0]);
      if (breakGravAccs.length > 40) { // ca. 2s bei 20Hz
        breakCalibState = 'done';
        // Mittelwerte berechnen
        let avgAccel = [0,0,0];
        breakAccs.forEach(v=>{avgAccel[0]+=v[0];avgAccel[1]+=v[1];avgAccel[2]+=v[2];});
        avgAccel = avgAccel.map(x=>x/(breakAccs.length||1));
        let avgGrav = [0,0,0];
        breakGravAccs.forEach(v=>{avgGrav[0]+=v[0];avgGrav[1]+=v[1];avgGrav[2]+=v[2];});
        avgGrav = avgGrav.map(x=>x/(breakGravAccs.length||1));
        // Normiere Vektoren
        let norm = v => { let m=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return m>0?[v[0]/m,v[1]/m,v[2]/m]:[0,0,1]; };
        let yAxis = norm(avgAccel);
        let zAxis = norm(avgGrav);
        // Berechne Rotationsmatrix, dann Euler-Winkel
        // x-Achse = y x z
        let xAxis = [yAxis[1]*zAxis[2]-yAxis[2]*zAxis[1], yAxis[2]*zAxis[0]-yAxis[0]*zAxis[2], yAxis[0]*zAxis[1]-yAxis[1]*zAxis[0]];
        // Rotation aus Basisvektoren
        // ZYX-Konvention
        let wx = Math.atan2(-yAxis[2],zAxis[2])*180/Math.PI;
        let wy = Math.atan2(xAxis[2],Math.sqrt(xAxis[0]*xAxis[0]+xAxis[1]*xAxis[1]))*180/Math.PI;
        let wz = Math.atan2(yAxis[0],yAxis[1])*180/Math.PI;
        document.getElementById('winkelX').value = wx.toFixed(1);
        document.getElementById('winkelY').value = wy.toFixed(1);
        document.getElementById('winkelZ').value = wz.toFixed(1);
        if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Kalibrierung abgeschlossen.'; }
        breakCalibState = null;
        breakAccs = [];
        breakGravAccs = [];
        if (breakTimeout) { clearTimeout(breakTimeout); breakTimeout = null; }
      }
    } else {
      breakGravAccs = [];
    }
  }
});
// --- GPS Geschwindigkeit und Position ---
if ('geolocation' in navigator) {
  navigator.geolocation.watchPosition(function(pos) {
    if (pos.coords.speed != null) {
      let currentSpeed = Math.max(0, pos.coords.speed);
      document.getElementById('speed').innerHTML = `Geschwindigkeit: ${currentSpeed.toFixed(2)} m/s`;
    }
    if (pos.coords.latitude != null && pos.coords.longitude != null) {
      document.getElementById('gps').innerHTML = `GPS: ${pos.coords.latitude.toFixed(6)} / ${pos.coords.longitude.toFixed(6)}`;
    }
  }, function(err) {
    document.getElementById('speed').innerHTML = 'GPS nicht verfügbar';
    document.getElementById('gps').innerHTML = 'GPS: - / -';
  }, { enableHighAccuracy: true, maximumAge: 1000 });
} else {
  document.getElementById('speed').innerHTML = 'GPS nicht verfügbar';
  document.getElementById('gps').innerHTML = 'GPS: - / -';
}

// Buttons für Schwellenwert-Änderung
document.getElementById('decelLeft').onclick = function() {
  let input = document.getElementById('decelThreshold');
  let val = parseFloat(input.value) || 0;
  val = Math.max(0, val - 0.1);
  input.value = val.toFixed(1);
  input.dispatchEvent(new Event('input'));
};
document.getElementById('decelRight').onclick = function() {
  let input = document.getElementById('decelThreshold');
  let val = parseFloat(input.value) || 0;
  val = Math.max(0, val + 0.1);
  input.value = val.toFixed(1);
  input.dispatchEvent(new Event('input'));
};

// Buttons für Schwellenwert Stillstand (stopThreshold)
document.getElementById('stopLeft').onclick = function() {
  let input = document.getElementById('stopThreshold');
  let val = parseFloat(input.value) || 0;
  val = Math.max(0, val - 0.01);
  input.value = val.toFixed(2);
  input.dispatchEvent(new Event('input'));
};
document.getElementById('stopRight').onclick = function() {
  let input = document.getElementById('stopThreshold');
  let val = parseFloat(input.value) || 0;
  val = Math.max(0, val + 0.01);
  input.value = val.toFixed(2);
  input.dispatchEvent(new Event('input'));
};

// Clear-Buttons für Winkel-Eingabefelder
document.getElementById('clearWinkelX').onclick = function() {
  document.getElementById('winkelX').value = 0;
};
document.getElementById('clearWinkelY').onclick = function() {
  document.getElementById('winkelY').value = 0;
};
document.getElementById('clearWinkelZ').onclick = function() {
  document.getElementById('winkelZ').value = 0;
};

// --- Bildschirm-anhalten/Wake Lock ---
let wakeLock = null;
async function requestWakeLock() {
  if ('wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Bildschirm bleibt an (Wake Lock aktiv).'; }
      wakeLock.addEventListener('release', () => {
        if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Wake Lock wurde freigegeben.'; }
      });
    } catch (err) {
      if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Wake Lock Fehler: ' + err.message; }
    }
  } else {
    if (document.getElementById('status')) { document.getElementById('status').innerHTML = 'Wake Lock wird nicht unterstützt.'; }
  }
}
// Versuche Wake Lock bei User-Interaktion und Sichtbarkeitswechsel
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') requestWakeLock();
  else if (wakeLock) { wakeLock.release(); wakeLock = null; }
});
window.addEventListener('touchstart', requestWakeLock, { once: true });
window.addEventListener('mousedown', requestWakeLock, { once: true });
// Optional: direkt beim Laden versuchen
requestWakeLock();
</script>
</body>
</html>