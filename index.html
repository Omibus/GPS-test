<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bremsweg-Messung Mobil</title>
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #f5f6fa; margin: 0; }
    .container { max-width: 400px; margin: 2rem auto; background: #fff; border-radius: 1rem; box-shadow: 0 4px 24px rgba(0,0,0,0.12); padding: 2rem; padding-left:2rem; padding-right:2rem; }
    h1 { text-align: center; }
    label { display: block; margin-top: 1rem; }
    input, select { width: 100%; padding: 0.5rem; margin: 0; border-radius: 0.5rem; border: 1px solid #ccc; box-sizing: border-box; height: 2.5em; }
    button { margin-top: 1.5rem; width: 100%; padding: 1rem; border: none; border-radius: 0.5rem; background: #4cd137; color: #fff; font-size: 1.2rem; cursor: pointer; box-sizing: border-box; }
    .inline-btn, .inline-btn-clear {
      width: calc(2.5em + 2px); /* exakt wie input inkl. border */
      height: calc(2.5em + 2px);
      padding: 0;
      margin: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      border-radius: 0.5em;
      border: 1px solid #ccc;
      background: #eee;
      color: #222;
      box-sizing: border-box;
    }
    .inline-btn-clear { color:#e84118; font-size:1.3em; }
    .inline-btn:active, .inline-btn-clear:active { background:#ddd; }
    .flex-row { display:flex; align-items:center; gap:0.5em; margin-top:0.5em; }
    .flex-row { display:flex; align-items:center; gap:0.5em; margin-top:0.5em; }
    button:disabled { background: #aaa; }
    .result { margin-top: 2rem; background: #f0f0f0; padding: 1rem; border-radius: 0.5rem; }
    .status { margin-top: 1rem; color: #888; font-size: 0.9rem; }
    .speed { font-size: 1.2rem; margin-top: 1rem; text-align: center; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Bremsweg-Messung</h1>
    <div class="speed" id="speed">Geschwindigkeit: 0 m/s</div>
    <div class="speed" id="gps">GPS: - / -</div>
    <div style="margin-top:0.5rem; display:flex; gap:0.5em; align-items:center;">
      <button id="calibBtn" type="button" style="background:#fbc531;color:#222;padding:0.5em 1em;border:none;border-radius:0.5em;">calib. grav.</button>
      <button id="calibBreakBtn" type="button" style="background:#00a8ff;color:#fff;padding:0.5em 1em;border:none;border-radius:0.5em;">calib. break</button>
    </div>
    <div class="flex-row"><span>Schwellenwert Verzögerung (m/s²):</span>
      <button id="decelLeft" type="button" class="inline-btn">-</button>
      <input type="number" id="decelThreshold" value="2" min="0" step="0.1" style="flex:1;min-width:60px;">
      <button id="decelRight" type="button" class="inline-btn">+</button>
    </div>
    <div class="flex-row"><span>Schwellenwert Stillstand (m/s²):</span>
      <button id="stopLeft" type="button" class="inline-btn">-</button>
      <input type="number" id="stopThreshold" value="0.3" min="0" step="0.01" style="flex:1;min-width:60px;">
      <button id="stopRight" type="button" class="inline-btn">+</button>
    </div>
    <div class="flex-row"><span>Richtung (X, Y, Z, Betrag):</span>
      <select id="direction" style="flex:1;">
        <option value="x">X</option>
        <option value="y" selected>Y</option>
        <option value="z">Z</option>
        <option value="betrag">Betrag</option>
      </select>
    </div>
    <div class="flex-row"><span>Verdrehwinkel um X (°):</span>
      <input type="number" id="winkelX" value="0" min="-180" max="180" step="0.1" style="flex:1;">
      <button id="clearWinkelX" type="button" class="inline-btn-clear">&#10006;</button>
    </div>
    <div class="flex-row"><span>Verdrehwinkel um Y (°):</span>
      <input type="number" id="winkelY" value="0" min="-180" max="180" step="0.1" style="flex:1;">
      <button id="clearWinkelY" type="button" class="inline-btn-clear">&#10006;</button>
    </div>
    <div class="flex-row"><span>Verdrehwinkel um Z (°):</span>
      <input type="number" id="winkelZ" value="0" min="-180" max="180" step="0.1" style="flex:1;">
      <button id="clearWinkelZ" type="button" class="inline-btn-clear">&#10006;</button>
    </div>
    <label style="margin-top:0.5rem;display:block;">
      <input type="checkbox" id="gravityToggle">
      Mit Gravitation messen
    </label>
    <button id="startBtn">Messung starten</button>
    <button id="stopBtn" style="background:#e84118;margin-top:0.5rem;">Messung beenden</button>
    <button id="clearBtn" style="background:#888;margin-top:0.5rem;">Clear</button>
    <div class="speed" id="acceleration">Verzögerung: 0 m/s²</div>
    <div class="status" id="status"></div>
    <div class="result" id="result"></div>
    <div class="result" id="resultsList"></div>
    <button id="exportBtn" style="background:#0097e6;margin-top:1.5rem;">Export als Excel</button>
  </div>
  <script>
    let measuring = false;
    let waitingForDecel = false;
    let postStopTimeout = null;
    let startTime = null;
    let stopTime = null;
    let decelThreshold = 2;
    let stopThreshold = 0.3;
    let direction = 'y';
    let useGravity = false;
    let startSpeed = 0;
    let currentSpeed = 0;
    let distance = 0;
    let lastSpeed = 0;
    let watchId = null;
    let results = [];
    let accHistory = []; // Für Plot und Mittelwert (Messintervall inkl. Vor- und Nachlauf)
    let accBuffer = []; // Kontinuierlicher Puffer für Rohdaten (1s Vorlauf)
    let accHistories = []; // Für Excel-Export
    let plotPNGs = []; // Für Anzeige der Historie
    const ACC_BUFFER_SEC = 1.0; // 1s Vorlauf
    const ACC_BUFFER_MAXLEN = Math.round(ACC_BUFFER_SEC / 0.02); // ca. 50 Werte bei 50Hz
    let postStopActive = false;
    let postStopStart = null;

    document.getElementById('startBtn').onclick = function() {
      decelThreshold = parseFloat(document.getElementById('decelThreshold').value);
      stopThreshold = parseFloat(document.getElementById('stopThreshold').value);
      direction = document.getElementById('direction').value;
      measuring = false;
      waitingForDecel = true;
      startTime = null;
      stopTime = null;
      distance = 0;
      document.getElementById('result').innerHTML = '';
      document.getElementById('status').innerHTML = 'Warte auf Verzögerung...';
      document.getElementById('acceleration').innerHTML = 'Verzögerung: 0 m/s²';
    };

    document.getElementById('direction').onchange = function() {
      direction = document.getElementById('direction').value;
    };
    document.getElementById('winkelX').oninput = function() {
  if (this.value === '' || isNaN(this.value)) this.value = 0;
};
document.getElementById('winkelY').oninput = function() {
  if (this.value === '' || isNaN(this.value)) this.value = 0;
};
document.getElementById('winkelZ').oninput = function() {
  if (this.value === '' || isNaN(this.value)) this.value = 0;
};
document.getElementById('clearWinkelX').onclick = function() {
  document.getElementById('winkelX').value = 0;
  document.getElementById('winkelX').dispatchEvent(new Event('input'));
};
document.getElementById('clearWinkelY').onclick = function() {
  document.getElementById('winkelY').value = 0;
  document.getElementById('winkelY').dispatchEvent(new Event('input'));
};
document.getElementById('clearWinkelZ').onclick = function() {
  document.getElementById('winkelZ').value = 0;
  document.getElementById('winkelZ').dispatchEvent(new Event('input'));
};
    document.getElementById('gravityToggle').onchange = function() {
      useGravity = document.getElementById('gravityToggle').checked;
    };

    document.getElementById('stopBtn').onclick = function() {
      measuring = false;
      waitingForDecel = false;
      startTime = null;
      stopTime = null;
      distance = 0;
      document.getElementById('result').innerHTML = '';
      document.getElementById('status').innerHTML = 'Messung gestoppt. Werte können angepasst werden.';
      document.getElementById('acceleration').innerHTML = 'Verzögerung: 0 m/s²';
    };

    document.getElementById('clearBtn').onclick = function() {
      results = [];
      updateResultsList();
    };

    function calcNormBremsweg(accHistory, startSpeed, bremszeit) {
  // 1. Normiere die Verzögerungskurve so, dass die Geschwindigkeit am Ende 0 ist
  // 2. Integriere die Geschwindigkeit über die Zeit für den Bremsweg
  let n = accHistory.length;
  if (n < 2) return 0;
  // Zeitdifferenzen und Roh-Integral der Verzögerung
  let v = [parseFloat(startSpeed)];
  let t0 = accHistory[0].t;
  let tN = accHistory[n-1].t;
  let dtSum = 0;
  for (let i=1; i<n; i++) {
    let dt = accHistory[i].t - accHistory[i-1].t;
    dtSum += dt;
    v[i] = v[i-1] - accHistory[i].a * dt; // Roh-Geschwindigkeit
  }
  // Normierungsfaktor berechnen, damit v[n-1] = 0
  let norm = v[n-1] !== 0 ? v[0] / (v[0] - v[n-1]) : 1;
  // Normierte Verzögerungskurve
  let vNorm = [v[0]];
  for (let i=1; i<n; i++) {
    let dt = accHistory[i].t - accHistory[i-1].t;
    vNorm[i] = vNorm[i-1] - accHistory[i].a * norm * dt;
  }
  // Bremsweg als Integral der normierten Geschwindigkeit
  let s = 0;
  for (let i=1; i<n; i++) {
    let dt = accHistory[i].t - accHistory[i-1].t;
    s += (vNorm[i-1] + vNorm[i]) / 2 * dt;
  }
  return s;
}

    function updateResultsList() {
      const listDiv = document.getElementById('resultsList');
      if (results.length === 0) {
        listDiv.innerHTML = '';
        return;
      }
  let html = '<b>Messungen:</b>';
  results.forEach((r, i) => {
    html += `<div style='margin-bottom:1.5em;padding:0.5em;background:#f8f8f8;border-radius:0.5em;'>`;
    html += `<b>Nr. ${i+1}</b>: Zeit: ${r.time}s, Startgeschw.: ${r.startSpeed}m/s, Mittlere Verzögerung: ${r.meanA} m/s², Bremsweg: ${r.distance}m`;
    html += `<br><span style='color:#888;'>Vergleichsbremsweg (a konst.): ${r.vergleichsweg} m</span>`;
    html += `<br><span style='color:#888;'>Bremsweg (normierte Kurve): ${r.normBremsweg} m</span>`;
    if (plotPNGs[i]) {
      html += `<br><img src='${plotPNGs[i]}' style='width:320px;border:1px solid #ccc;margin-top:0.5em;'>`;
    }
    html += `</div>`;
  });
  listDiv.innerHTML = html;
    }

    document.getElementById('stopBtn').onclick = function() {
      measuring = false;
      startTime = null;
      stopTime = null;
      distance = 0;
      document.getElementById('result').innerHTML = '';
      document.getElementById('status').innerHTML = 'Messung gestoppt. Werte können angepasst werden.';
      document.getElementById('acceleration').innerHTML = 'Verzögerung: 0 m/s²';
    };

    // GPS Geschwindigkeit und Position
    if ('geolocation' in navigator) {
      watchId = navigator.geolocation.watchPosition(function(pos) {
        if (pos.coords.speed != null) {
          currentSpeed = Math.max(0, pos.coords.speed);
          document.getElementById('speed').innerHTML = `Geschwindigkeit: ${currentSpeed.toFixed(2)} m/s`;
        }
        if (pos.coords.latitude != null && pos.coords.longitude != null) {
          document.getElementById('gps').innerHTML = `GPS: ${pos.coords.latitude.toFixed(6)} / ${pos.coords.longitude.toFixed(6)}`;
        }
      }, function(err) {
        document.getElementById('speed').innerHTML = 'GPS nicht verfügbar';
        document.getElementById('gps').innerHTML = 'GPS: - / -';
      }, { enableHighAccuracy: true, maximumAge: 1000 });
    } else {
      document.getElementById('speed').innerHTML = 'GPS nicht verfügbar';
      document.getElementById('gps').innerHTML = 'GPS: - / -';
    }

    function rotateVector(x, y, z, wx, wy, wz) {
      // Rotationsmatrizen für x, y, z
      let radX = wx * Math.PI / 180;
      let radY = wy * Math.PI / 180;
      let radZ = wz * Math.PI / 180;
      // Rotation um X
      let y1 = y * Math.cos(radX) - z * Math.sin(radX);
      let z1 = y * Math.sin(radX) + z * Math.cos(radX);
      let x1 = x;
      // Rotation um Y
      let x2 = x1 * Math.cos(radY) + z1 * Math.sin(radY);
      let z2 = -x1 * Math.sin(radY) + z1 * Math.cos(radY);
      let y2 = y1;
      // Rotation um Z
      let x3 = x2 * Math.cos(radZ) - y2 * Math.sin(radZ);
      let y3 = x2 * Math.sin(radZ) + y2 * Math.cos(radZ);
      let z3 = z2;
      return {x: x3, y: y3, z: z3};
    }

    window.addEventListener('devicemotion', function(event) {
      let acc = useGravity ? event.accelerationIncludingGravity : event.acceleration;
      if (!acc) return;
      let wx = parseFloat(document.getElementById('winkelX').value) || 0;
      let wy = parseFloat(document.getElementById('winkelY').value) || 0;
      let wz = parseFloat(document.getElementById('winkelZ').value) || 0;
      let vec = rotateVector(acc.x || 0, acc.y || 0, acc.z || 0, wx, wy, wz);
      let a = 0;
      if (direction === 'betrag') {
        a = Math.sqrt(
          Math.pow(vec.x, 2) +
          Math.pow(vec.y, 2) +
          Math.pow(vec.z, 2)
        );
      } else {
        a = vec[direction] || 0;
      }
      // --- accBuffer: Rohdatenpuffer für 1s Vorlauf ---
      let now = performance.now();
      accBuffer.push({t: now, a: a});
      while (accBuffer.length > 0 && (now - accBuffer[0].t) > 1100) accBuffer.shift();
      document.getElementById('acceleration').innerHTML = `Verzögerung${useGravity ? ' inkl. Gravitation' : ''}: ${a.toFixed(2)} m/s²`;

      // --- Trigger-Logik: Start bei Überschreiten des Schwellenwerts (nur Betrag) ---
      if (waitingForDecel) {
        // Prüfe, ob der Schwellenwert zwischen dem aktuellen und dem vorigen Wert überschritten wurde
        let prev = accBuffer.length > 1 ? accBuffer[accBuffer.length-2] : null;
        let prevAbsA = prev ? Math.abs(prev.a) : null;
        let currAbsA = Math.abs(a);
        // Interpolation nur, wenn Schwellenwert zwischen zwei Messwerten liegt
        if (prev && prevAbsA !== null && prevAbsA < decelThreshold && currAbsA >= decelThreshold) {
          // Lineare Interpolation für exakten Zeitpunkt und Wert
          let t1 = prev.t;
          let t2 = now;
          let a1 = prev.a;
          let a2 = a;
          let absA1 = Math.abs(a1);
          let absA2 = Math.abs(a2);
          let frac = (decelThreshold - absA1) / (absA2 - absA1);
          let tCross = t1 + frac * (t2 - t1);
          let aCross = a1 + frac * (a2 - a1);
          measuring = true;
          waitingForDecel = false;
          startTime = tCross;
          startSpeed = currentSpeed;
          let tThresh = tCross;
          let preBuffer = accBuffer.filter(d => (tThresh - d.t) <= 1100);
          let t0 = preBuffer.length > 0 ? preBuffer[0].t : tThresh;
          accHistory = preBuffer.map(d => ({ t: (d.t - t0)/1000, a: d.a, absTime: d.t }));
          // Füge interpolierten Startpunkt als eigenen Wert ein
          accHistory.push({ t: (tThresh - t0)/1000, a: aCross, absTime: tThresh, _interpolated: true });
          window._tThreshStartRel = (tThresh - t0)/1000;
          window._t0Abs = t0;
          window._tThreshAbs = tThresh;
          window._tThreshEndAbs = null;
          document.getElementById('status').innerHTML = 'Messung läuft...';
        } else if (currAbsA === decelThreshold) {
          // Exakter Treffer: KEINE Interpolation, sondern Messwert direkt verwenden
          measuring = true;
          waitingForDecel = false;
          startTime = now;
          startSpeed = currentSpeed;
          let tThresh = now;
          let preBuffer = accBuffer.filter(d => (tThresh - d.t) <= 1100);
          let t0 = preBuffer.length > 0 ? preBuffer[0].t : tThresh;
          accHistory = preBuffer.map(d => ({ t: (d.t - t0)/1000, a: d.a, absTime: d.t }));
          // Kein interpolierter Punkt, sondern echter Messwert
          window._tThreshStartRel = (tThresh - t0)/1000;
          window._t0Abs = t0;
          window._tThreshAbs = tThresh;
          window._tThreshEndAbs = null;
          document.getElementById('status').innerHTML = 'Messung läuft...';
        }
      }

      // --- Während Messung: Werte kontinuierlich aufzeichnen ---
      if (measuring) {
        let dt = event.interval ? event.interval / 1000 : 0.02;
        startSpeed = startSpeed || currentSpeed;
        startSpeed = Math.max(0, startSpeed);
        startSpeed = isNaN(startSpeed) ? 0 : startSpeed;
        startSpeed = Math.max(startSpeed, 0);
        startSpeed = Math.min(startSpeed, 100);
        startSpeed = parseFloat(startSpeed);
        currentSpeed -= Math.abs(a) * dt;
        if (currentSpeed < 0) currentSpeed = 0;
        distance += currentSpeed * dt;
        // Verzögerung und Zeit für Plot speichern
        let t = (now - startTime) / 1000;
        let absTime = now;
        accHistory.push({t: t, a: a, absTime: absTime});

        // --- Stop-Schwellenwert erreicht? ---
        if (!window._tThreshEndAbs) {
          // Prüfe, ob der Schwellenwert zwischen dem aktuellen und dem vorigen Wert unterschritten wurde ODER ein Vorzeichenwechsel stattfand
          let prev = accHistory.length > 1 ? accHistory[accHistory.length-2] : null;
          let curr = { t: (now - startTime) / 1000, a: a, absTime: now };
          if (prev) {
            let prevAbsA = Math.abs(prev.a);
            let currAbsA = Math.abs(a);
            let prevA = prev.a;
            let currA = a;
            let t1 = prev.absTime;
            let t2 = now;
            let tCross = null;
            // Fall 1: Betrag unterschreitet Schwellenwert (von >= auf <)
            if (prevAbsA >= stopThreshold && currAbsA < stopThreshold) {
              let a1 = prevAbsA;
              let a2 = currAbsA;
              let frac = (a1 - stopThreshold) / (a1 - a2);
              tCross = t1 + frac * (t2 - t1);
            }
            // Fall 2: Vorzeichenwechsel (a1 * a2 < 0)
            if (tCross === null && prevA * currA < 0) {
              let a1 = prevA;
              let a2 = currA;
              let frac = -a1 / (a2 - a1);
              tCross = t1 + frac * (t2 - t1);
            }
            // Fall 3: Exakter Treffer (Betrag == Schwellenwert)
            if (tCross === null && currAbsA === stopThreshold) {
              tCross = now;
            }
            if (tCross !== null && window._tThreshEndAbs === null) {
              window._tThreshEndAbs = tCross;
              window._tThreshEndRel = (tCross - window._t0Abs)/1000;
              // 1 Sekunde nach Stop noch weiter aufzeichnen
              if (!window._postStopTimeout) {
                window._postStopTimeout = setTimeout(function() {
                  measuring = false;
                  stopTime = performance.now();
                  // --- accHistory auf 1s nach Stop-Schwellenwert beschränken ---
                  let tEndAbs = window._tThreshEndAbs;
                  let t0 = window._t0Abs;
                  accHistory = accHistory.filter(d => d.absTime >= t0 && d.absTime <= (tEndAbs + 1000));
                  accHistory = accHistory.map(d => ({ t: (d.absTime - t0)/1000, a: d.a }));
                  // Doppelte Zeitstempel entfernen
                  let seen = new Set();
                  accHistory = accHistory.filter(d => {
                    let key = d.t.toFixed(5);
                    if (seen.has(key)) return false;
                    seen.add(key); return true;
                  });
                  // Effektive Bremszeit: Zeit zwischen erstem und zweitem Schwellenwert
                  let tStartThresh = window._tThreshStartRel || 0;
                  let tEndThresh = window._tThreshEndRel || (accHistory[accHistory.length-1]?.t || 0);

                  // Nur Werte im Bremsintervall für Auswertung verwenden
                  let brakeData = accHistory.filter(d => d.t >= tStartThresh && d.t <= tEndThresh);

                  // --- Interpolierte Schwellenwertpunkte für exaktes Intervall einfügen (falls nötig) ---
                  // Startpunkt
                  if (brakeData.length === 0 || Math.abs(brakeData[0].t - tStartThresh) > 1e-6) {
                    // Finde umgebende Punkte
                    let before = null, after = null;
                    for (let i = 1; i < accHistory.length; i++) {
                      if (accHistory[i-1].t <= tStartThresh && accHistory[i].t >= tStartThresh) {
                        before = accHistory[i-1];
                        after = accHistory[i];
                        break;
                      }
                    }
                    if (before && after) {
                      let frac = (tStartThresh - before.t) / (after.t - before.t);
                      let aInterp = before.a + frac * (after.a - before.a);
                      brakeData.unshift({ t: tStartThresh, a: aInterp });
                    }
                  }
                  // Endpunkt
                  if (brakeData.length === 0 || Math.abs(brakeData[brakeData.length-1].t - tEndThresh) > 1e-6) {
                    let before = null, after = null;
                    for (let i = 1; i < accHistory.length; i++) {
                      if (accHistory[i-1].t <= tEndThresh && accHistory[i].t >= tEndThresh) {
                        before = accHistory[i-1];
                        after = accHistory[i];
                        break;
                      }
                    }
                    if (before && after) {
                      let frac = (tEndThresh - before.t) / (after.t - before.t);
                      let aInterp = before.a + frac * (after.a - before.a);
                      brakeData.push({ t: tEndThresh, a: aInterp });
                    }
                  }

                  // Mittelwert der Verzögerung berechnen (geglättet)
                  let meanA = 0;
                  if (brakeData.length > 1) {
                    let sum = 0;
                    for (let i = 1; i < brakeData.length; i++) {
                      let dt = brakeData[i].t - brakeData[i-1].t;
                      sum += Math.abs(brakeData[i].a) * dt;
                    }
                    meanA = sum / (brakeData[brakeData.length-1].t);
                  }
                  // Vergleichsbremsweg bei konstanter Verzögerung
                  let vergleichsweg = meanA > 0 ? (Math.pow(startSpeed,2)/(2*meanA)) : 0;
                  // Alternative Methode: normierte Verzögerungskurve
                  let normBremsweg = calcNormBremsweg(brakeData, startSpeed, tEndThresh - tStartThresh);
                  document.getElementById('result').innerHTML =
                    `<b>Messung beendet!</b><br>Benötigte Zeit: ${time} s<br>Geschätzter Weg: ${distance.toFixed(2)} m<br>Startgeschwindigkeit: ${startSpeed.toFixed(2)} m/s` +
                    `<br>Mittlere Verzögerung: ${meanA.toFixed(2)} m/s²` +
                    `<br><span style='color:#888;'>Vergleichsbremsweg (konstant): ${vergleichsweg.toFixed(2)} m</span>` +
                    `<br><span style='color:#888;'>Bremsweg (normierte Kurve): ${normBremsweg.toFixed(2)} m</span>`;
                  document.getElementById('status').innerHTML = 'Stillstand erkannt.';
                  // Plot anzeigen und PNG für Historie erzeugen
                  let png = showAccPlot(accHistory, true, {
                    tThreshStart: tStartThresh,
                    tThreshEnd: tEndThresh
                  });
                  plotPNGs.push(png);
                  // Messwerte für Excel speichern
                  accHistories.push(accHistory.map(d => ({t: d.t, a: d.a})));
                  // Ergebnis speichern und anzeigen
                  results.push({
                    time: time,
                    startSpeed: startSpeed.toFixed(2),
                    distance: distance.toFixed(2),
                    vergleichsweg: vergleichsweg.toFixed(2),
                    meanA: meanA.toFixed(2),
                    normBremsweg: normBremsweg.toFixed(2)
                  });
                  updateResultsList();
                  // App zurücksetzen für neue Messung
                  waitingForDecel = false;
                  measuring = false;
                  window._postStopTimeout = null;
                }, 1000);
              }
            }
          }
        }
        // Nachlauf: Nach erstem Unterschreiten des End-Schwellenwerts werden nur noch Werte für die Anzeige gesammelt, aber keine Trigger-Prüfung mehr durchgeführt.
      }
    });

// Plot-Funktion für Verzögerung über Zeit
function showAccPlot(data, returnPNG=false, opts={}) {
  // opts: { tThreshStart, tThreshEnd }
  let plotDiv = document.getElementById('result');
  let w = 320, h = 140, pad = 40;
  let canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  canvas.style.marginTop = '1em';
  let ctx = canvas.getContext('2d');
  // Zeitbereich bestimmen
  let tStart = 0;
  let tEnd = data[data.length-1].t;
  // Wertebereich bestimmen
  let amin = Math.min(...data.map(d=>d.a));
  let amax = Math.max(...data.map(d=>d.a));
  if (amin === amax) { amin -= 1; amax += 1; }
  // y=0 (a=0) bestimmen
  let y0 = h-pad - (h-2*pad) * ((0-amin)/(amax-amin));

  // --- Achsen zeichnen ---
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  // x-Achse (a=0)
  ctx.moveTo(pad, y0);
  ctx.lineTo(w-pad, y0);
  // y-Achse
  ctx.moveTo(pad, h-pad);
  ctx.lineTo(pad, pad);
  ctx.stroke();

  // --- Achsenbeschriftungen ---
  ctx.fillStyle = '#222';
  ctx.font = '12px Segoe UI';
  ctx.textAlign = 'center';
  // X-Achse
  ctx.fillText('Zeit (s)', w/2, h-4);
  // Y-Achse: ganz links oben an der Achse, horizontal
  ctx.textAlign = 'left';
  ctx.fillText('a (m/s²)', pad-32, pad-8);

  // --- Wertebereichsbeschriftung ---
  ctx.fillStyle = '#444';
  ctx.font = '12px Segoe UI';
  ctx.textAlign = 'right';
  ctx.fillText(amin.toFixed(1), pad-5, h-pad);
  ctx.fillText(amax.toFixed(1), pad-5, pad+5);
  // X-Achse Werte
  ctx.textAlign = 'center';
  ctx.font = '12px Segoe UI';
  ctx.fillText((tStart).toFixed(2), pad, h-pad+15);
  ctx.fillText((tEnd).toFixed(2), w-pad, h-pad+15);

  // --- Plot der Kurve abschnittsweise (grau/rot/grau) ---
  const graphLineWidth = 2;
  ctx.lineWidth = graphLineWidth;
  let tEvalStart = opts.tThreshStart;
  let tEvalEnd = opts.tThreshEnd;

  // Zeichne abschnittsweise
  let lastColor = null;
  ctx.beginPath();
  for (let i = 0; i < data.length-1; i++) {
    let t0 = data[i].t, t1 = data[i+1].t;
    let a0 = data[i].a, a1 = data[i+1].a;
    let x0 = pad + (w-2*pad) * ((t0-tStart)/(tEnd-tStart));
    let y0p = h-pad - (h-2*pad) * ((a0-amin)/(amax-amin));
    let x1 = pad + (w-2*pad) * ((t1-tStart)/(tEnd-tStart));
    let y1p = h-pad - (h-2*pad) * ((a1-amin)/(amax-amin));

    // Abschnittsfarbe bestimmen
    let segStart = t0, segEnd = t1;
    let segColor = '#bbb';
    if (tEvalStart !== undefined && tEvalEnd !== undefined) {
      if (segEnd <= tEvalStart || segStart >= tEvalEnd) {
        segColor = '#bbb';
      } else if (segStart >= tEvalStart && segEnd <= tEvalEnd) {
        segColor = '#e84118';
      } else {
        // Segment schneidet einen Schwellenwert: splitten und beide Teile zeichnen
        if (segStart < tEvalStart && segEnd > tEvalStart && segEnd <= tEvalEnd) {
          // Split bei tEvalStart
          let frac = (tEvalStart - segStart) / (segEnd - segStart);
          let xSplit = x0 + frac * (x1 - x0);
          let ySplit = y0p + frac * (y1p - y0p);
          // Grau bis tEvalStart
          ctx.strokeStyle = '#bbb';
          ctx.beginPath();
          ctx.moveTo(x0, y0p);
          ctx.lineTo(xSplit, ySplit);
          ctx.stroke();
          // Rot ab tEvalStart
          ctx.strokeStyle = '#e84118';
          ctx.beginPath();
          ctx.moveTo(xSplit, ySplit);
          ctx.lineTo(x1, y1p);
          ctx.stroke();
          continue;
        } else if (segStart >= tEvalStart && segStart < tEvalEnd && segEnd > tEvalEnd) {
          // Split bei tEvalEnd
          let frac = (tEvalEnd - segStart) / (segEnd - segStart);
          let xSplit = x0 + frac * (x1 - x0);
          let ySplit = y0p + frac * (y1p - y0p);
          // Rot bis tEvalEnd
          ctx.strokeStyle = '#e84118';
          ctx.beginPath();
          ctx.moveTo(x0, y0p);
          ctx.lineTo(xSplit, ySplit);
          ctx.stroke();
          // Grau ab tEvalEnd
          ctx.strokeStyle = '#bbb';
          ctx.beginPath();
          ctx.moveTo(xSplit, ySplit);
          ctx.lineTo(x1, y1p);
          ctx.stroke();
          continue;
        } else if (segStart < tEvalStart && segEnd > tEvalEnd) {
          // Split bei beiden Schwellenwerten
          let frac1 = (tEvalStart - segStart) / (segEnd - segStart);
          let xSplit1 = x0 + frac1 * (x1 - x0);
          let ySplit1 = y0p + frac1 * (y1p - y0p);
          let frac2 = (tEvalEnd - segStart) / (segEnd - segStart);
          let xSplit2 = x0 + frac2 * (x1 - x0);
          let ySplit2 = y0p + frac2 * (y1p - y0p);
          // Grau bis tEvalStart
          ctx.strokeStyle = '#bbb';
          ctx.beginPath();
          ctx.moveTo(x0, y0p);
          ctx.lineTo(xSplit1, ySplit1);
          ctx.stroke();
          // Rot zwischen tEvalStart und tEvalEnd
          ctx.strokeStyle = '#e84118';
          ctx.beginPath();
          ctx.moveTo(xSplit1, ySplit1);
          ctx.lineTo(xSplit2, ySplit2);
          ctx.stroke();
          // Grau ab tEvalEnd
          ctx.strokeStyle = '#bbb';
          ctx.beginPath();
          ctx.moveTo(xSplit2, ySplit2);
          ctx.lineTo(x1, y1p);
          ctx.stroke();
          continue;
        }
      }
    } else if (tEvalStart !== undefined && segStart >= tEvalStart) {
      segColor = '#e84118';
    }
    ctx.strokeStyle = segColor;
    ctx.beginPath();
    ctx.moveTo(x0, y0p);
    ctx.lineTo(x1, y1p);
    ctx.stroke();
  }

  // --- Schwellenwert-Marker und Zeitmarken ---
  // Marker für Start (grün)
  if (tEvalStart !== undefined) {
    // Suche Punkt mit exakt passender Zeit (egal ob interpoliert oder echter Messwert)
    let idx = data.findIndex(d => Math.abs(d.t - tEvalStart) < 1e-6);
    let d;
    if (idx >= 0) {
      d = data[idx];
    } else {
      // Fallback: Interpolieren zwischen den beiden umgebenden Punkten
      let before = null, after = null;
      for (let i = 1; i < data.length; i++) {
        if (data[i-1].t <= tEvalStart && data[i].t >= tEvalStart) {
          before = data[i-1];
          after = data[i];
          break;
        }
      }
      if (before && after) {
        let frac = (tEvalStart - before.t) / (after.t - before.t);
        let aInterp = before.a + frac * (after.a - before.a);
        d = { t: tEvalStart, a: aInterp };
      }
    }
    if (d) {
      let x = pad + (w-2*pad) * ((d.t-tStart)/(tEnd-tStart));
      let y = h-pad - (h-2*pad) * ((d.a-amin)/(amax-amin));
      // Punkt
      ctx.beginPath();
      ctx.arc(x, y, graphLineWidth*2, 0, 2*Math.PI);
      ctx.fillStyle = '#27ae60'; // kräftiges grün
      ctx.fill();
      // Vertikale gepunktete Linie
      ctx.save();
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = '#e84118'; // rot wie Auswertebereich
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, h-pad+18);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      // Zeitwert unter Achse
      ctx.save();
      ctx.font = 'bold 13px Segoe UI';
      ctx.fillStyle = '#e84118';
      ctx.textAlign = 'center';
      ctx.fillText(d.t.toFixed(2) + 's', x, h-pad+32);
      ctx.restore();
    }
  }
  // Marker für Ende (blau)
  if (tEvalEnd !== undefined) {
    // Suche Punkt mit exakt passender Zeit (egal ob interpoliert oder echter Messwert)
    let idx = data.findIndex(d => Math.abs(d.t - tEvalEnd) < 1e-6);
    let d;
    if (idx >= 0) {
      d = data[idx];
    } else {
      // Fallback: Interpolieren zwischen den beiden umgebenden Punkten
      let before = null, after = null;
      for (let i = 1; i < data.length; i++) {
        if (data[i-1].t <= tEvalEnd && data[i].t >= tEvalEnd) {
          before = data[i-1];
          after = data[i];
          break;
        }
      }
      if (before && after) {
        let frac = (tEvalEnd - before.t) / (after.t - before.t);
        let aInterp = before.a + frac * (after.a - before.a);
        d = { t: tEvalEnd, a: aInterp };
      }
    }
    if (d) {
      let x = pad + (w-2*pad) * ((d.t-tStart)/(tEnd-tStart));
      let y = h-pad - (h-2*pad) * ((d.a-amin)/(amax-amin));
      // Punkt
      ctx.beginPath();
      ctx.arc(x, y, graphLineWidth*2, 0, 2*Math.PI);
      ctx.fillStyle = '#0097e6'; // kräftiges blau
      ctx.fill();
      // Vertikale gepunktete Linie
      ctx.save();
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = '#0097e6';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, h-pad+18);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      // Zeitwert unter Achse
      ctx.save();
      ctx.font = 'bold 13px Segoe UI';
      ctx.fillStyle = '#0097e6';
      ctx.textAlign = 'center';
      ctx.fillText(d.t.toFixed(2) + 's', x, h-pad+32);
      ctx.restore();
    }
  }

  if (!returnPNG) {
    plotDiv.appendChild(canvas);
    return;
  } else {
    return canvas.toDataURL('image/png');
  }
}
// SheetJS für Excel-Export einbinden
let sheetjsLoaded = false;
function loadSheetJS(cb) {
  if (sheetjsLoaded) { cb(); return; }
  let script = document.createElement('script');
  script.src = 'https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js';
  script.onload = function() { sheetjsLoaded = true; cb(); };
  document.body.appendChild(script);
}

document.getElementById('exportBtn').onclick = function() {
  loadSheetJS(function() {
    let wb = XLSX.utils.book_new();
    let ws_data = [['Nr','Zeit (s)','Startgeschw. (m/s)','Bremsweg (m)','Vergleichsbremsweg (m)','Mittlere Verzögerung (m/s²)','Bremsweg (normierte Kurve)']];
    results.forEach((r,i)=>{
      ws_data.push([i+1, r.time, r.startSpeed, r.distance, r.vergleichsweg, r.meanA, r.normBremsweg]);
    });
    let ws = XLSX.utils.aoa_to_sheet(ws_data);
    XLSX.utils.book_append_sheet(wb, ws, 'Messungen');
    // Messwerte als weitere Sheets
    accHistories.forEach((hist,i)=>{
      let plotData = [['Zeit (s)','Verzögerung (m/s²)']];
      hist.forEach(d=>{
        plotData.push([d.t.toFixed(3), d.a.toFixed(3)]);
      });
      let plotSheet = XLSX.utils.aoa_to_sheet(plotData);
      XLSX.utils.book_append_sheet(wb, plotSheet, `Plot${i+1}`);
    });
    XLSX.writeFile(wb, 'bremsweg_messungen.xlsx');
  });
};

document.getElementById('calibBtn').onclick = function() {
  // Hole aktuelle Beschleunigung inkl. Gravitation
  let acc = window.lastAccInclGrav;
  if (!acc) {
    alert('Keine Beschleunigungsdaten verfügbar. Bitte das Gerät ruhig halten und kurz warten.');
    return;
  }
  // Berechne Winkel zwischen Beschleunigungsvektor und Z-Achse
  let ax = acc.x || 0;
  let ay = acc.y || 0;
  let az = acc.z || 0;
  let g = Math.sqrt(ax*ax + ay*ay + az*az);
  if (g === 0) {
    alert('Ungültige Sensordaten.');
    return;
  }
  // Winkel zur Z-Achse (in Grad)
  let winkelX = Math.acos(az/g) * 180 / Math.PI;
  if (ax < 0) winkelX = -winkelX;
  document.getElementById('winkelX').value = winkelX.toFixed(1);
};
let breakCalibState = null;
let breakAccs = [];
let breakGravAccs = [];
let breakTimeout = null;
document.getElementById('calibBreakBtn').onclick = function() {
  if (breakCalibState) return;
  breakCalibState = 'waitForAccel';
  breakAccs = [];
  breakGravAccs = [];
  if (breakTimeout) { clearTimeout(breakTimeout); breakTimeout = null; }
  // Schwellenwerte aus den Eingabefeldern holen
  window.breakDecelThreshold = parseFloat(document.getElementById('decelThreshold').value) || 2;
  window.breakStopThreshold = parseFloat(document.getElementById('stopThreshold').value) || 0.3;
  document.getElementById('status').innerHTML = `Warte auf Bremsbeschleunigung (>${window.breakDecelThreshold} m/s²)...`;
};

window.lastAccInclGrav = null;
window.addEventListener('devicemotion', function(event) {
  window.lastAccInclGrav = event.accelerationIncludingGravity;
  // Kalibrierung break
  if (breakCalibState === 'waitForAccel') {
    let acc = event.acceleration;
    if (!acc) return;
    let aVec = [acc.x||0, acc.y||0, acc.z||0];
    let aMag = Math.sqrt(aVec[0]*aVec[0]+aVec[1]*aVec[1]+aVec[2]*aVec[2]);
    if (aMag > ((window.breakDecelThreshold !== undefined ? window.breakDecelThreshold : 2))) {
      breakCalibState = 'measureAccel';
      breakAccs = [];
      document.getElementById('status').innerHTML = 'Messe Bremsrichtung...';
      if (breakTimeout) { clearTimeout(breakTimeout); breakTimeout = null; }
      breakTimeout = setTimeout(function(){
        breakCalibState = 'waitForStill';
        breakGravAccs = [];
        document.getElementById('status').innerHTML = `Warte auf Stillstand (<${window.breakStopThreshold !== undefined ? window.breakStopThreshold : 0.2} m/s² für 2s)...`;
        breakTimeout = null;
      }, 500);
    }
  }
  if (breakCalibState === 'measureAccel') {
    let acc = event.acceleration;
    if (!acc) return;
    breakAccs.push([acc.x||0, acc.y||0, acc.z||0]);
  }
  if (breakCalibState === 'waitForStill') {
    let acc = event.acceleration;
    if (!acc) return;
    let aVec = [acc.x||0, acc.y||0, acc.z||0];
    let aMag = Math.sqrt(aVec[0]*aVec[0]+aVec[1]*aVec[1]+aVec[2]*aVec[2]);
    if (aMag < ((window.breakStopThreshold !== undefined ? window.breakStopThreshold : 0.2))) {
      breakGravAccs.push(window.lastAccInclGrav ? [window.lastAccInclGrav.x||0, window.lastAccInclGrav.y||0, window.lastAccInclGrav.z||0] : [0,0,0]);
      if (breakGravAccs.length > 40) { // ca. 2s bei 20Hz
        breakCalibState = 'done';
        // Mittelwerte berechnen
        let avgAccel = [0,0,0];
        breakAccs.forEach(v=>{avgAccel[0]+=v[0];avgAccel[1]+=v[1];avgAccel[2]+=v[2];});
        avgAccel = avgAccel.map(x=>x/(breakAccs.length||1));
        let avgGrav = [0,0,0];
        breakGravAccs.forEach(v=>{avgGrav[0]+=v[0];avgGrav[1]+=v[1];avgGrav[2]+=v[2];});
        avgGrav = avgGrav.map(x=>x/(breakGravAccs.length||1));
        // Normiere Vektoren
        let norm = v => { let m=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return m>0?[v[0]/m,v[1]/m,v[2]/m]:[0,0,1]; };
        let yAxis = norm(avgAccel);
        let zAxis = norm(avgGrav);
        // Berechne Rotationsmatrix, dann Euler-Winkel
        // x-Achse = y x z
        let xAxis = [yAxis[1]*zAxis[2]-yAxis[2]*zAxis[1], yAxis[2]*zAxis[0]-yAxis[0]*zAxis[2], yAxis[0]*zAxis[1]-yAxis[1]*zAxis[0]];
        // Rotation aus Basisvektoren
        // ZYX-Konvention
        let wx = Math.atan2(-yAxis[2],zAxis[2])*180/Math.PI;
        let wy = Math.atan2(xAxis[2],Math.sqrt(xAxis[0]*xAxis[0]+xAxis[1]*xAxis[1]))*180/Math.PI;
        let wz = Math.atan2(yAxis[0],yAxis[1])*180/Math.PI;
        document.getElementById('winkelX').value = wx.toFixed(1);
        document.getElementById('winkelY').value = wy.toFixed(1);
        document.getElementById('winkelZ').value = wz.toFixed(1);
        document.getElementById('status').innerHTML = 'Kalibrierung abgeschlossen.';
        breakCalibState = null;
        breakAccs = [];
        breakGravAccs = [];
        if (breakTimeout) { clearTimeout(breakTimeout); breakTimeout = null; }
      }
    } else {
      breakGravAccs = [];
    }
  }
});
// Buttons für Schwellenwert-Änderung
  document.getElementById('decelLeft').onclick = function() {
    let input = document.getElementById('decelThreshold');
    let val = parseFloat(input.value) || 0;
    val = Math.max(0, val - 0.1);
    input.value = val.toFixed(1);
    input.dispatchEvent(new Event('input'));
  };
  document.getElementById('decelRight').onclick = function() {
    let input = document.getElementById('decelThreshold');
    let val = parseFloat(input.value) || 0;
    val = val + 0.1;
    input.value = val.toFixed(1);
    input.dispatchEvent(new Event('input'));
  };
  document.getElementById('stopLeft').onclick = function() {
    let input = document.getElementById('stopThreshold');
    let val = parseFloat(input.value) || 0;
    val = Math.max(0, val - 0.1);
    input.value = val.toFixed(2);
    input.dispatchEvent(new Event('input'));
  };
  document.getElementById('stopRight').onclick = function() {
    let input = document.getElementById('stopThreshold');
    let val = parseFloat(input.value) || 0;
    val = val + 0.1;
    input.value = val.toFixed(2);
    input.dispatchEvent(new Event('input'));
  };
  </script>
  <script>
    // --- Bildschirm-anhalten/Wake Lock ---
    let wakeLock = null;
    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          document.getElementById('status').innerHTML = 'Bildschirm bleibt an (Wake Lock aktiv).';
          wakeLock.addEventListener('release', () => {
            document.getElementById('status').innerHTML = 'Wake Lock wurde freigegeben.';
          });
        } catch (err) {
          document.getElementById('status').innerHTML = 'Wake Lock Fehler: ' + err.message;
        }
      } else {
        document.getElementById('status').innerHTML = 'Wake Lock wird nicht unterstützt.';
      }
    }
    // Versuche Wake Lock bei User-Interaktion und Sichtbarkeitswechsel
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') requestWakeLock();
      else if (wakeLock) { wakeLock.release(); wakeLock = null; }
    });
    window.addEventListener('touchstart', requestWakeLock, { once: true });
    window.addEventListener('mousedown', requestWakeLock, { once: true });
    // Optional: direkt beim Laden versuchen
    requestWakeLock();
  </script>
</body>
</html>
    requestWakeLock();
  </script>
</body>
</html>
